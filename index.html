<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Sync with Firebase</title>
    <style>
        :root {
            --yt-red: #FF0000;
            --yt-red-hover: #c00;
            --yt-dark: #212121;
            --yt-light-dark: #333;
            
            /* Light Theme Variables */
            --primary-background: #f9f9f9;
            --secondary-background: #ffffff;
            --primary-text: #030303;
            --secondary-text: #606060;
            --border-color: #e0e0e0;
            --hover-background: #f2f2f2;
            --input-background: #ffffff;
            --header-background: var(--yt-dark);
            --header-text: #ffffff;
            --search-button-bg: #f8f8f8;
            --search-input-bg: #fff;
            --search-input-border: #ccc;
            --search-input-focus-border: #1c62b9;
        }

        body.dark {
            /* Dark Theme Variables */
            --primary-background: #0f0f0f;
            --secondary-background: #212121;
            --primary-text: #f1f1f1;
            --secondary-text: #aaaaaa;
            --border-color: #3d3d3d;
            --hover-background: #3d3d3d;
            --input-background: #121212;
            --header-background: #212121;
            --header-text: #ffffff;
            --search-button-bg: #3d3d3d;
            --search-input-bg: #121212;
            --search-input-border: #303030;
            --search-input-focus-border: var(--yt-red);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Arial', sans-serif;
            margin: 0;
            background-color: var(--primary-background);
            color: var(--primary-text);
            transition: background-color 0.2s, color 0.2s;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 16px 0 24px;
            height: 56px;
            background-color: var(--header-background);
            color: var(--header-text);
        }

        .logo-container {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .logo-container h1 {
            font-size: 20px;
            margin: 0;
            font-weight: 500;
        }

        .search-container-header {
            flex: 0 1 728px;
            display: flex;
        }
        
        #searchInput {
            width: 100%;
            padding: 10px 12px;
            font-size: 16px;
            border-radius: 40px 0 0 40px;
            border: 1px solid var(--search-input-border);
            background-color: var(--search-input-bg);
            color: var(--primary-text);
        }
        #searchInput:focus {
            border-color: var(--search-input-focus-border);
            outline: none;
        }

        #searchButton {
            padding: 0 24px;
            border-radius: 0 40px 40px 0;
            border: 1px solid var(--search-input-border);
            border-left: none;
            cursor: pointer;
            background-color: var(--hover-background);
        }
        #searchButton svg {
            fill: var(--primary-text);
        }

        .user-actions {
            display: flex;
            align-items: center;
            margin-left: 16px;
        }

        #darkModeToggle {
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #darkModeToggle:hover {
            background-color: var(--yt-light-dark);
        }
        #darkModeToggle svg {
            fill: var(--header-text);
        }

        .moon-icon { display: none; }
        body.dark .sun-icon { display: none; }
        body.dark .moon-icon { display: block; }

        .page-container {
            display: flex;
            flex-direction: column;
            padding: 24px;
            max-width: 1440px;
            margin: 0 auto;
        }

        @media (min-width: 1024px) {
            .page-container {
                display: grid;
                grid-template-columns: 1fr 402px;
                gap: 24px;
                align-items: flex-start;
            }
        }

        .main-content {
            flex: 1;
            min-width: 0;
        }
        
        @media (min-width: 1024px) {
            .main-content {
                grid-column: 1 / 2;
                grid-row: 1 / 2;
            }
        }

        .sidebar {
            width: 100%;
            max-width: 402px;
            margin: 24px auto 0 auto;
        }
        
        @media (min-width: 1024px) {
            .sidebar {
                grid-column: 2 / 3;
                grid-row: 1 / 3;
                width: 402px;
                margin: 0;
                flex-shrink: 0;
            }
        }

        .sidebar-section {
            background-color: var(--secondary-background);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }
        
        .sidebar-section h2, .sidebar-section h3 {
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
            margin-bottom: 12px;
            color: var(--primary-text);
        }

        .player-container {
            width: 100%;
            aspect-ratio: 16 / 9;
            background-color: #000;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        #player {
            width: 100%;
            height: 100%;
        }

        #results, #queueList {
            list-style: none;
            padding: 0;
            max-height: 300px;
            overflow-y: auto;
        }

        #results li, #queueList li {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 8px;
            border-radius: 4px;
        }
        #results li:hover, #queueList li:hover {
            background-color: var(--hover-background);
        }
        #results img, #queueList img {
            width: 120px;
            height: 67px;
            object-fit: cover;
            border-radius: 4px;
            flex-shrink: 0;
        }
        
        .video-info {
            flex-grow: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            min-width: 0;
        }

        .video-title {
            font-weight: 500;
            color: var(--primary-text);
            white-space: normal;
            overflow: hidden;
            text-overflow: ellipsis;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
        }
        
        .queue-btn, .remove-btn {
            padding: 6px 12px;
            font-size: 12px;
            flex-shrink: 0;
            background-color: var(--hover-background);
            color: var(--primary-text);
            border: 1px solid var(--border-color);
            border-radius: 18px;
            cursor: pointer;
        }
        body.dark .queue-btn, body.dark .remove-btn {
            background-color: var(--yt-light-dark);
        }

        .user-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .user-container {
            background: var(--secondary-background);
            color: var(--primary-text);
            padding: 24px;
            border-radius: 12px;
            text-align: center;
        }
        .user-container input {
            background-color: var(--input-background);
            color: var(--primary-text);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 8px;
            margin: 0 8px;
        }
        
        #inviteLink { font-size: 14px; background-color: var(--input-background); color: var(--primary-text); border: 1px solid var(--border-color); padding: 8px; border-radius: 8px; width: calc(100% - 16px); }
        #createInviteBtn { width: 100%; margin-bottom: 10px;}

        #userList { list-style-type: none; padding-left: 0; }
        #userList li { background-color: var(--primary-background); padding: 8px 12px; border-radius: 4px; margin-bottom: 5px; }

        .status { text-align: center; font-weight: bold; padding: 12px; border-radius: 6px; margin-top: 10px; }
        .status.connected { background-color: #d1e7dd; color: #0f5132; }
        .status.disconnected { background-color: #f8d7da; color: #842029; }
        .status.connecting { background-color: #fff3cd; color: #664d03; }
        button { background-color: var(--yt-red); color: white; padding: 10px 16px; border: none; border-radius: 40px; cursor: pointer; font-size: 14px; font-weight: 500; transition: background-color 0.2s; }
        button:hover { background-color: var(--yt-red-hover); }

        .chat-container {
            margin-top: 24px;
        }
        @media (min-width: 1024px) {
            .chat-container {
                grid-column: 1 / 2;
                grid-row: 2 / 3;
            }
        }
        .chat-messages {
            height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border-color);
            background-color: var(--primary-background);
            padding: 10px;
            margin-bottom: 10px;
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            gap: 16px;
        }
        .chat-message {
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }
        .avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            flex-shrink: 0;
            font-size: 18px;
        }
        .message-body {
            display: flex;
            flex-direction: column;
        }
        .sender {
            font-weight: 500;
            font-size: 14px;
            margin-bottom: 2px;
            color: var(--primary-text);
        }
        .message-text {
            font-size: 14px;
            line-height: 1.4;
            color: var(--primary-text);
        }
        .chat-input-container {
            display: flex;
            gap: 8px;
        }
        #chatInput {
            flex-grow: 1;
            border-radius: 20px;
            background-color: var(--input-background);
            border: 1px solid var(--border-color);
            color: var(--primary-text);
            padding: 10px;
        }
        #sendChatBtn {
            padding: 10px 20px;
        }
        
        /* --- Toolbar & Theater Mode Styles --- */
        .player-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            margin-top: 8px;
            background-color: var(--secondary-background);
            border: 1px solid var(--border-color);
            border-radius: 12px;
        }

        .video-title-toolbar {
            flex-grow: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-weight: bold;
            font-size: 16px;
            padding-right: 16px;
        }

        #theaterModeBtn {
            background: none;
            border: 1px solid var(--border-color);
            color: var(--primary-text);
            padding: 8px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            flex-shrink: 0;
        }
        #theaterModeBtn:hover {
            background-color: var(--hover-background);
        }
        #theaterModeBtn svg {
            stroke: var(--primary-text);
        }

        body.theater-mode .main-content {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: #000;
            z-index: 500;
            padding: 0;
            margin: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }
        body.theater-mode .player-container {
            width: 100%;
            height: 100%;
            border-radius: 0;
        }
        body.theater-mode .player-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            right: 10px;
            margin-top: 0;
            background-color: rgba(0,0,0,0.5);
            border: 1px solid rgba(255,255,255,0.2);
        }
        body.theater-mode .video-title-toolbar {
            color: #fff;
        }
         body.theater-mode #theaterModeBtn {
            border-color: rgba(255,255,255,0.2);
         }
          body.theater-mode #theaterModeBtn svg {
            stroke: #fff;
         }
          body.theater-mode #theaterModeBtn:hover {
            background-color: rgba(255,255,255,0.2);
         }
        body.theater-mode .header, body.theater-mode .sidebar, body.theater-mode .chat-container, body.theater-mode .page-container > .main-content ~ * {
            display: none;
        }

        .expand-icon { display: block; }
        .close-icon { display: none; }
        body.theater-mode .expand-icon { display: none; }
        body.theater-mode .close-icon { display: block; }

        .hidden { display: none !important; }

    </style>
</head>
<body>

<div class="user-modal" id="userModal">
    <div class="user-container">
        <h2>Welcome to YouTube Party</h2>
        <p>Please enter your name to join or start a party.</p>
        <input type="text" id="userName" placeholder="Enter your name...">
        <button id="setNameBtn" disabled>Continue</button>
    </div>
</div>

<div id="mainContent" class="hidden">
    <div class="header">
        <div class="logo-container">
            <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="white" focusable="false"><path d="M10 16.5l6-4.5-6-4.5v9zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></svg>
            <h1>YouTube Party</h1>
        </div>
        <div class="search-container-header">
            <input type="text" id="searchInput" placeholder="Search for a YouTube video...">
            <button id="searchButton">
                <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" focusable="false"><path d="M20.87 20.17l-5.59-5.59C16.35 13.35 17 11.75 17 10c0-3.87-3.13-7-7-7s-7 3.13-7 7 3.13 7 7 7c1.75 0 3.35-.65 4.58-1.71l5.59 5.59.71-.71zM10 16c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"></path></svg>
            </button>
        </div>
        <div class="user-actions">
            <button id="darkModeToggle" title="Toggle dark mode">
                <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
            </button>
        </div>
    </div>
    
    <div class="page-container">
        <div class="main-content">
            <div class="player-container"><div id="player"></div></div>
            <div class="player-controls">
                <div id="videoTitle" class="video-title-toolbar">No video loaded</div>
                <button id="theaterModeBtn" title="Theater Mode">
                    <svg class="expand-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                    <svg class="close-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
        </div>

        <div class="sidebar">
            <div class="sidebar-section">
                <h2>Search</h2>
                <ul id="results"></ul>
            </div>
            
            <div class="sidebar-section">
                <h2>Queue</h2>
                <ul id="queueList"></ul>
            </div>

            <div class="sidebar-section">
                <h2>Party Sync</h2>
                <div id="connectionManagement">
                    <button id="createInviteBtn">Create Invite Link</button>
                    <input type="text" id="inviteLink" class="hidden" readonly>
                </div>
                <h3>Connected Users</h3>
                <ul id="userList"></ul>
                <div id="connectionStatus" class="status disconnected">Status: Disconnected</div>
            </div>
        </div>

        <div class="chat-container sidebar-section">
            <h3>Live Chat</h3>
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
                <input type="text" id="chatInput" placeholder="Say something...">
                <button id="sendChatBtn">Send</button>
            </div>
        </div>
    </div>
</div>

<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-functions-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-auth-compat.js"></script>
<script src="https://www.youtube.com/iframe_api"></script>

<script>
    // --- DARK MODE LOGIC ---
    const darkModeToggle = document.getElementById('darkModeToggle');
    if (localStorage.getItem('theme') === 'dark') {
        document.body.classList.add('dark');
    }
    darkModeToggle.addEventListener('click', () => {
        document.body.classList.toggle('dark');
        if (document.body.classList.contains('dark')) {
            localStorage.setItem('theme', 'dark');
        } else {
            localStorage.setItem('theme', 'light');
        }
    });

    // --- CONFIGURATION ---
    const firebaseConfig = {
        apiKey: "AIzaSyActKLRV4ldSsS1dKNwkXXdKblnwG0s654", 
        authDomain: "partysync-17cd5.firebaseapp.com",
        projectId: "partysync-17cd5",
        storageBucket: "partysync-17cd5.appspot.com",
        messagingSenderId: "294351433712",
        appId: "1:294351433712:web:826470510443b924a6b735",
        measurementId: "G-PF73SF4VGY"
    };

    // --- INITIALIZE FIREBASE ---
    const app = firebase.initializeApp(firebaseConfig);
    const db = app.firestore();

    // --- DOM ELEMENTS ---
    const userModal = document.getElementById('userModal');
    const userNameInput = document.getElementById('userName');
    const setNameBtn = document.getElementById('setNameBtn');
    const mainContent = document.getElementById('mainContent');
    const searchButton = document.getElementById('searchButton');
    const searchInput = document.getElementById('searchInput');
    const resultsList = document.getElementById('results');
    const queueList = document.getElementById('queueList');
    const connectionStatus = document.getElementById('connectionStatus');
    const createInviteBtn = document.getElementById('createInviteBtn');
    const inviteLinkInput = document.getElementById('inviteLink');
    const userList = document.getElementById('userList');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const sendChatBtn = document.getElementById('sendChatBtn');
    const videoTitleElement = document.getElementById('videoTitle');

    // --- APP STATE ---
    let myName = '';
    let player;
    let isHost = false;
    let partyId = '';
    let myAuthId = null; 
    let currentHostId = '';
    const peerConnections = {};
    const dataChannels = {};
    let partyDocRef;
    let videoQueue = [];
    let isSyncingFromHost = false;
    let lastPlayerState = -1;
    let officialVideoDuration = 0;
    let hostHeartbeatInterval;
    let lastUserActionTimestamp = 0;
    let intentToAutoPlay = false;
    let localUserList = {};

    // --- AUTHENTICATION & APP START ---
    firebase.auth().onAuthStateChanged(user => {
        if (user) {
            myAuthId = user.uid;
            console.log("User signed in with UID:", myAuthId);
            setNameBtn.disabled = false;
        } else {
            myAuthId = null;
            setNameBtn.disabled = true;
        }
    });

    setNameBtn.disabled = true;
    firebase.auth().signInAnonymously().catch((error) => {
        console.error("Anonymous sign-in failed:", error);
        alert("Could not connect to the service. Please refresh the page.");
    });

    // --- INITIALIZATION ---
    setNameBtn.addEventListener('click', () => {
        const name = userNameInput.value.trim();
        if (name && myAuthId) {
            myName = name;
            userModal.classList.add('hidden');
            mainContent.classList.remove('hidden');
            initApp();
        } else if (!name) {
            alert('Please enter a name.');
        } else {
            alert('Could not verify connection. Please refresh the page.');
        }
    });

    function initApp() {
        const urlParams = new URLSearchParams(window.location.search);
        partyId = urlParams.get('party');
        if (partyId) {
            isHost = false;
            createInviteBtn.classList.add('hidden');
            joinParty();
        } else {
            isHost = true;
            startHostHeartbeat();
        }
        sendChatBtn.addEventListener('click', sendChatMessage);
        chatInput.addEventListener('keypress', e => {
            if (e.key === 'Enter') sendChatMessage();
        });
        window.addEventListener('beforeunload', () => {
            const data = { type: 'USER_LEAVING' };
            Object.values(dataChannels).forEach(channel => {
                if (channel && channel.readyState === 'open') {
                    channel.send(JSON.stringify(data));
                }
            });
        });
    }

    // --- THEATER MODE ---
    const theaterModeBtn = document.getElementById('theaterModeBtn');
    theaterModeBtn.addEventListener('click', () => {
        document.body.classList.toggle('theater-mode');
        const inTheaterMode = document.body.classList.contains('theater-mode');
        theaterModeBtn.title = inTheaterMode ? 'Exit Theater Mode' : 'Theater Mode';
    });
    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && document.body.classList.contains('theater-mode')) {
            document.body.classList.remove('theater-mode');
            theaterModeBtn.title = 'Theater Mode';
        }
    });

    // --- YOUTUBE API ---
    window.onYouTubeIframeAPIReady = () => player = new YT.Player('player', {
        videoId: '',
        events: { 'onStateChange': onPlayerStateChange }
    });
    searchButton.addEventListener('click', searchYouTube);
    searchInput.addEventListener('keypress', e => e.key === 'Enter' && searchYouTube());

    async function searchYouTube() {
        const query = searchInput.value;
        if (!query) return;
        const searchYoutubeFunction = app.functions('us-central1').httpsCallable('searchYoutube');
        try {
            console.log("Calling Cloud Function with query:", query);
            const result = await searchYoutubeFunction({ query: query });
            displayResults(result.data.items || []);
            console.log("Received results:", result.data.items);
        } catch (error) {
            console.error("Error calling Cloud Function:", error);
            alert("Could not fetch search results. Check the console for details.");
        }
    }

    function displayResults(videos) {
        resultsList.innerHTML = videos.length ? '' : '<li>No videos found.</li>';
        videos.forEach(video => {
            const videoId = video.id.videoId;
            const title = video.snippet.title;
            const thumbnailUrl = video.snippet.thumbnails.default.url;
            const li = document.createElement('li');
            li.dataset.videoId = videoId;
            li.innerHTML = `<img src="${thumbnailUrl}" alt="${title}"><div class="video-info"><div class="video-title" title="Play Now">${title}</div><button class="queue-btn">Add</button></div>`;
            const clickableElements = [li.querySelector('img'), li.querySelector('.video-title')];
            clickableElements.forEach(el => el.addEventListener('click', () => handleUserAction({ type: 'NEW_VIDEO', videoId: videoId, autoPlay: true })));
            li.querySelector('.queue-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                const videoData = { videoId, title, thumbnailUrl };
                handleUserAction({ type: 'ADD_TO_QUEUE', video: videoData });
            });
            resultsList.appendChild(li);
        });
    }

    // --- WEBRTC & FIREBASE SIGNALING ---
    createInviteBtn.addEventListener('click', async () => {
        if (!myAuthId) return alert("Cannot create party, not connected.");
        isHost = true;
        partyId = crypto.randomUUID();
        currentHostId = myAuthId;
        const url = `${window.location.href.split('?')[0]}?party=${partyId}`;
        inviteLinkInput.value = url;
        inviteLinkInput.classList.remove('hidden');
        createInviteBtn.disabled = true;
        partyDocRef = db.collection('parties').doc(partyId);
        await partyDocRef.set({
            hostId: myAuthId,
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });
        listenForGuests();
        startHostHeartbeat();
    });

    async function joinParty() {
        if (!myAuthId) return alert("Cannot join party, not connected.");
        partyDocRef = db.collection('parties').doc(partyId);
        const guestDocRef = partyDocRef.collection('guests').doc(myAuthId);
        const pc = createPeerConnection('host');
        dataChannels['host'] = pc.createDataChannel('sync-channel');
        configureDataChannel('host', dataChannels['host']);
        const guestCandidatesRef = guestDocRef.collection('guestCandidates');
        pc.onicecandidate = event => {
            if (event.candidate) {
                guestCandidatesRef.add(event.candidate.toJSON());
            }
        };
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        await guestDocRef.set({ offer, name: myName });
        guestDocRef.onSnapshot(async (snapshot) => {
            const data = snapshot.data();
            if (data && data.answer && !pc.currentRemoteDescription) {
                await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
            }
        });
        guestDocRef.collection('hostCandidates').onSnapshot(snapshot => {
            snapshot.docChanges().forEach(change => {
                if (change.type === 'added') {
                    pc.addIceCandidate(new RTCIceCandidate(change.doc.data()));
                }
            });
        });
    }

    function listenForGuests() {
        partyDocRef.collection('guests').onSnapshot(async snapshot => {
            for (const change of snapshot.docChanges()) {
                if (change.type === 'added') {
                    const guestId = change.doc.id;
                    if (peerConnections[guestId]) continue;
                    const guestDocRef = change.doc.ref;
                    const { offer, name } = change.doc.data();
                    const pc = createPeerConnection(guestId, name);
                    pc.ondatachannel = event => {
                        dataChannels[guestId] = event.channel;
                        configureDataChannel(guestId, event.channel, name);
                    };
                    const hostCandidatesRef = guestDocRef.collection('hostCandidates');
                    pc.onicecandidate = event => {
                        if (event.candidate) {
                            hostCandidatesRef.add(event.candidate.toJSON());
                        }
                    };
                    await pc.setRemoteDescription(new RTCSessionDescription(offer));
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    await guestDocRef.update({ answer });
                    guestDocRef.collection('guestCandidates').onSnapshot(snap => {
                        snap.docChanges().forEach(ch => {
                            if (ch.type === 'added') {
                                pc.addIceCandidate(new RTCIceCandidate(ch.doc.data()));
                            }
                        });
                    });
                }
            }
        });
    }

    function createPeerConnection(peerId, peerName) {
        const pc = new RTCPeerConnection({ iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] });
        peerConnections[peerId] = pc;
        pc.peerName = peerName;
        pc.onconnectionstatechange = () => {
            updateConnectionStatus();
            if (peerId === 'host' && !isHost) {
                const state = pc.connectionState;
                if (state === 'disconnected' || state === 'failed' || state === 'closed') {
                    console.warn(`Connection to host lost. State: ${state}`);
                    if (!window.migrationInProgress) {
                        window.migrationInProgress = true;
                        handleHostDisconnection();
                    }
                }
            }
        };
        return pc;
    }

    function sendChatMessage() {
        const text = chatInput.value.trim();
        if (text) {
            const messageData = { type: 'CHAT_MESSAGE', text: text, sender: myName };
            Object.values(dataChannels).forEach(channel => {
                if (channel && channel.readyState === 'open') {
                    channel.send(JSON.stringify(messageData));
                }
            });
            displayChatMessage(messageData);
            chatInput.value = '';
        }
    }

    function displayChatMessage({ text, sender }) {
        const messageEl = document.createElement('div');
        messageEl.classList.add('chat-message');
        const avatarEl = document.createElement('div');
        avatarEl.classList.add('avatar');
        avatarEl.textContent = sender.charAt(0).toUpperCase();
        avatarEl.style.backgroundColor = getUserColor(sender);
        const messageBodyEl = document.createElement('div');
        messageBodyEl.classList.add('message-body');
        const senderEl = document.createElement('div');
        senderEl.classList.add('sender');
        senderEl.textContent = sender;
        const textEl = document.createElement('div');
        textEl.classList.add('message-text');
        textEl.textContent = text;
        messageBodyEl.appendChild(senderEl);
        messageBodyEl.appendChild(textEl);
        messageEl.appendChild(avatarEl);
        messageEl.appendChild(messageBodyEl);
        chatMessages.appendChild(messageEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    function handleUserAction(data) {
        if (isHost) {
            broadcastData(data);
        } else {
            sendRequestToHost(data);
        }
    }

    function sendRequestToHost(data) {
        if (isHost) return;
        if (data.type === 'STATE_CHANGE' && officialVideoDuration > 0) {
            const currentDuration = player.getDuration();
            if (currentDuration === 0 || Math.abs(currentDuration - officialVideoDuration) > 2) {
                console.log("Ad or buffer detected. Suppressing request to host.");
                return;
            }
        }
        const requestData = { ...data, type: `REQUEST_${data.type}` };
        const hostChannel = dataChannels['host'];
        if (hostChannel && hostChannel.readyState === 'open') {
            hostChannel.send(JSON.stringify(requestData));
        }
    }

    function broadcastData(data) {
        handleReceivedData(data, 'local');
        Object.entries(dataChannels).forEach(([id, channel]) => {
            if (id !== 'host' && channel && channel.readyState === 'open') {
                channel.send(JSON.stringify(data));
            }
        });
    }

    function configureDataChannel(peerId, channel, peerName = '') {
        channel.onopen = () => {
            window.migrationInProgress = false;
            updateConnectionStatus();
            if (isHost) {
                const users = { [myAuthId]: { name: myName } };
                Object.entries(peerConnections).forEach(([id, pc]) => {
                    if (pc.peerName) users[id] = { name: pc.peerName };
                });
                broadcastData({ type: 'USER_LIST', users });
                channel.send(JSON.stringify({ type: 'HOST_INFO', hostId: myAuthId }));
                if (player && player.getPlayerState && player.getPlayerState() !== YT.PlayerState.UNSTARTED && player.getVideoData().video_id) {
                    const syncData = { type: 'INITIAL_SYNC', videoId: player.getVideoData().video_id, time: player.getCurrentTime(), state: player.getPlayerState(), duration: player.getDuration(), queue: videoQueue };
                    channel.send(JSON.stringify(syncData));
                } else {
                    broadcastData({ type: 'QUEUE_UPDATE', queue: videoQueue });
                }
            }
        };
        channel.onclose = () => {
            if (peerId === 'host' && !isHost && !window.migrationInProgress) {
                window.migrationInProgress = true;
                handleHostDisconnection();
                return;
            }
            if (isHost && partyDocRef) {
                partyDocRef.collection('guests').doc(peerId).delete().catch(error => console.error("Error removing guest document:", error));
            }
            delete peerConnections[peerId];
            delete dataChannels[peerId];
            updateConnectionStatus();
            if (isHost) {
                const users = { [myAuthId]: { name: myName } };
                Object.entries(peerConnections).forEach(([id, pc]) => {
                    if (pc.peerName) users[id] = { name: pc.peerName };
                });
                broadcastData({ type: 'USER_LIST', users });
            }
        };
        channel.onmessage = event => handleReceivedData(JSON.parse(event.data), peerId);
    }

    function onPlayerStateChange(event) {
        if (event.data === YT.PlayerState.PLAYING || event.data === YT.PlayerState.CUED) {
            updateVideoTitle();
        }
        if (isHost && intentToAutoPlay && event.data === YT.PlayerState.CUED) {
            intentToAutoPlay = false;
            handleUserAction({ type: 'STATE_CHANGE', state: YT.PlayerState.PLAYING, time: 0 });
            return;
        }
        if (isSyncingFromHost) {
            isSyncingFromHost = false;
            lastPlayerState = event.data;
            return;
        }
        if (event.data === YT.PlayerState.BUFFERING) { return; }
        if (event.data === lastPlayerState) { return; }
        lastUserActionTimestamp = Date.now();
        const newState = event.data;
        lastPlayerState = newState;
        if (isHost && newState === YT.PlayerState.PLAYING) {
            const duration = player.getDuration();
            if (Math.abs(duration - officialVideoDuration) > 1) {
                officialVideoDuration = duration;
                broadcastData({ type: 'VIDEO_DURATION', duration: duration });
            }
        }
        const actionData = { type: 'STATE_CHANGE', state: newState, time: player.getCurrentTime() };
        handleUserAction(actionData);
    }

    function handleReceivedData(data, senderId) {
        if (!player && data.type.includes('VIDEO')) return;
        if (isHost && data.type.startsWith('REQUEST_')) {
            const commandData = { ...data, type: data.type.replace('REQUEST_', '') };
            broadcastData(commandData);
            return;
        }
        switch (data.type) {
            case 'HOST_INFO':
                currentHostId = data.hostId;
                break;
            case 'INITIAL_SYNC':
                isSyncingFromHost = true;
                officialVideoDuration = data.duration;
                if (player.getVideoData()?.video_id !== data.videoId) {
                    player.loadVideoById(data.videoId, data.time);
                } else {
                    player.seekTo(data.time, true);
                }
                setTimeout(() => {
                    isSyncingFromHost = true;
                    if (data.state === YT.PlayerState.PLAYING) player.playVideo();
                    else if (data.state === YT.PlayerState.PAUSED) player.pauseVideo();
                }, 1000);
                videoQueue = data.queue;
                updateQueueUI();
                break;
            case 'VIDEO_DURATION':
                officialVideoDuration = data.duration;
                break;
            case 'NEW_VIDEO':
                isSyncingFromHost = true;
                officialVideoDuration = 0;
                if (player.getVideoData()?.video_id !== data.videoId) {
                    if (isHost && data.autoPlay) {
                        intentToAutoPlay = true;
                    }
                    player.loadVideoById(data.videoId);
                } else if (data.autoPlay) {
                    player.playVideo();
                }
                break;
            case 'STATE_CHANGE':
                if (isHost && senderId === 'local' && player.getPlayerState() === data.state) { return; }
                isSyncingFromHost = true;
                lastPlayerState = data.state;
                if (Math.abs(player.getCurrentTime() - data.time) > 3.5) {
                    player.seekTo(data.time, true);
                }
                if (data.state === YT.PlayerState.PLAYING) {
                    player.playVideo();
                } else if (data.state === YT.PlayerState.PAUSED || data.state === YT.PlayerState.ENDED) {
                    player.pauseVideo();
                }
                break;
            case 'TIME_UPDATE':
                if (!isHost) {
                    if (Date.now() - lastUserActionTimestamp < 3000) break;
                    const localTime = player.getCurrentTime();
                    const localState = player.getPlayerState();
                    const timeDifference = Math.abs(localTime - data.time);
                    if (data.state === YT.PlayerState.PLAYING && (localState !== YT.PlayerState.PLAYING || timeDifference > 3.5)) {
                        const currentDuration = player.getDuration();
                        if (officialVideoDuration > 0 && Math.abs(currentDuration - officialVideoDuration) > 2) {
                            break;
                        }
                        isSyncingFromHost = true;
                        player.seekTo(data.time, true);
                        player.playVideo();
                    }
                }
                break;
            case 'ADD_TO_QUEUE':
                if (isHost) {
                    videoQueue.push(data.video);
                    broadcastData({ type: 'QUEUE_UPDATE', queue: videoQueue });
                }
                break;
            case 'PLAY_FROM_QUEUE':
                if (isHost && videoQueue[data.index]) {
                    const videoToPlay = videoQueue.splice(data.index, 1)[0];
                    broadcastData({ type: 'NEW_VIDEO', videoId: videoToPlay.videoId, autoPlay: true });
                    broadcastData({ type: 'QUEUE_UPDATE', queue: videoQueue });
                }
                break;
            case 'REMOVE_FROM_QUEUE':
                if (isHost) {
                    videoQueue.splice(data.index, 1);
                    broadcastData({ type: 'QUEUE_UPDATE', queue: videoQueue });
                }
                break;
            case 'USER_LEAVING':
                if (isHost && peerConnections[senderId]) {
                    peerConnections[senderId].close();
                }
                break;
            case 'QUEUE_UPDATE':
                videoQueue = data.queue;
                updateQueueUI();
                break;
            case 'USER_LIST':
                updateUserList(data.users);
                break;
            case 'CHAT_MESSAGE':
                if (senderId !== 'local') displayChatMessage(data);
                break;
        }
    }

    function startHostHeartbeat() {
        if (hostHeartbeatInterval) clearInterval(hostHeartbeatInterval);
        hostHeartbeatInterval = setInterval(() => {
            if (isHost && player && typeof player.getCurrentTime === 'function') {
                const currentState = player.getPlayerState();
                if (currentState === YT.PlayerState.ENDED && videoQueue.length > 0) {
                    const nextVideo = videoQueue.shift();
                    broadcastData({ type: 'NEW_VIDEO', videoId: nextVideo.videoId, autoPlay: true });
                    broadcastData({ type: 'QUEUE_UPDATE', queue: videoQueue });
                    return;
                }
                const data = { type: 'TIME_UPDATE', time: player.getCurrentTime(), state: currentState };
                Object.entries(dataChannels).forEach(([id, channel]) => {
                    if (id !== 'host' && channel && channel.readyState === 'open') {
                        channel.send(JSON.stringify(data));
                    }
                });
            }
        }, 1500);
    }

    async function handleHostDisconnection() {
        console.log("Host disconnected. Starting election...");
        connectionStatus.textContent = 'Status: Host disconnected, electing new host...';
        connectionStatus.className = 'status connecting';
        if (hostHeartbeatInterval) clearInterval(hostHeartbeatInterval);
        delete localUserList[currentHostId];
        if (peerConnections['host']) {
            peerConnections['host'].close();
            delete peerConnections['host'];
        }
        if (dataChannels['host']) {
            delete dataChannels['host'];
        }
        const remainingClientIds = Object.keys(localUserList);
        if (!remainingClientIds.includes(myAuthId)) {
            remainingClientIds.push(myAuthId);
        }
        remainingClientIds.sort();
        if (remainingClientIds.length === 0) {
            console.log("Party is empty after host left.");
            return;
        }
        const newHostId = remainingClientIds[0];
        console.log("Election determined. New host should be:", newHostId);
        if (myAuthId === newHostId) {
            try {
                await partyDocRef.update({ hostId: myAuthId });
                console.log("This client has successfully become the new host!");
                isHost = true;
                currentHostId = myAuthId;
                updateUIForNewHost();
                listenForGuests();
                startHostHeartbeat();
                broadcastData({ type: 'USER_LIST', users: localUserList });
            } catch (error) {
                console.error("Error trying to become host:", error);
                alert("Could not elect new host. Please refresh the page.");
            }
        } else {
            console.log("Waiting for the new host to take over.");
            listenForNewHostAndReconnect();
        }
    }

    function listenForNewHostAndReconnect() {
        const unsubscribe = partyDocRef.onSnapshot(doc => {
            if (!doc.exists) return;
            const newHostId = doc.data().hostId;
            if (newHostId && newHostId !== myAuthId && newHostId !== currentHostId) {
                console.log(`New host detected (${newHostId}). Reconnecting...`);
                unsubscribe();
                currentHostId = newHostId;
                joinParty();
            }
        });
    }

    function updateUIForNewHost() {
        createInviteBtn.classList.remove('hidden');
        createInviteBtn.disabled = true;
        updateUserList(localUserList);
        updateConnectionStatus();
    }

    function updateVideoTitle() {
        if (player && typeof player.getVideoData === 'function') {
            const title = player.getVideoData().title;
            if (title) {
                videoTitleElement.textContent = title;
                videoTitleElement.title = title;
            }
        }
    }

    function updateQueueUI() {
        queueList.innerHTML = '';
        if (videoQueue.length === 0) {
            queueList.innerHTML = '<li>Queue is empty.</li>';
            return;
        }
        videoQueue.forEach((video, index) => {
            const li = document.createElement('li');
            li.title = "Click to Play Now";
            li.innerHTML = `<img src="${video.thumbnailUrl}" alt="${video.title}"><div class="video-info"><div class="video-title">${video.title}</div><button class="remove-btn" title="Remove from queue" data-index="${index}">Remove</button></div>`;
            li.addEventListener('click', (e) => {
                if (e.target.classList.contains('remove-btn')) return;
                handleUserAction({ type: 'PLAY_FROM_QUEUE', index });
            });
            li.querySelector('.remove-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                handleUserAction({ type: 'REMOVE_FROM_QUEUE', index });
            });
            queueList.appendChild(li);
        });
    }

    function updateConnectionStatus() {
        const states = Object.values(peerConnections).map(pc => pc.connectionState);
        let statusText = 'Disconnected';
        let statusClass = 'disconnected';
        const connectedCount = states.filter(s => s === 'connected').length;
        if (isHost && states.length === 0) {
            statusText = 'Waiting for guests...';
            statusClass = 'connecting';
        } else if (connectedCount > 0 || (!isHost && peerConnections['host'] && peerConnections['host'].connectionState === 'connected')) {
            statusText = `Connected to host`;
            statusClass = 'connected';
        } else if (!isHost && states.some(s => ['connecting', 'new', 'checking'].includes(s))) {
            statusText = 'Connecting...';
            statusClass = 'connecting';
        }
        connectionStatus.textContent = `Status: ${statusText}`;
        connectionStatus.className = `status ${statusClass}`;
    }

    function updateUserList(users = {}) {
        localUserList = users;
        userList.innerHTML = '';
        const uniqueUsers = {};
        Object.values(users).forEach(user => {
            if (user.name && !uniqueUsers[user.name]) {
                uniqueUsers[user.name] = user;
            }
        });
        if (!uniqueUsers[myName]) {
            uniqueUsers[myName] = { name: myName };
        }
        Object.values(uniqueUsers).forEach(user => {
            const li = document.createElement('li');
            let suffix = '';
            if (user.name === myName) {
                suffix = isHost ? ' (Host, You)' : ' (You)';
            }
            li.textContent = user.name + suffix;
            userList.appendChild(li);
        });
    }
    
    // --- UTILITY FUNCTIONS ---
    // (none needed for this example, but would go here)

</script>

</body>
</html>