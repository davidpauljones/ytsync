<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Sync with Firebase</title>
    <style>
        :root {
            --yt-red: #FF0000;
            --yt-red-hover: #c00;
            --yt-dark: #212121;
            --yt-light-dark: #333;
            --primary-background: #f9f9f9;
            --secondary-background: #ffffff;
            --primary-text: #030303;
            --secondary-text: #606060;
            --border-color: #e0e0e0;
            --hover-background: #f2f2f2;
            --input-background: #ffffff;
            --header-background: var(--yt-dark);
            --header-text: #ffffff;
            --search-button-bg: #f8f8f8;
            --search-input-bg: #fff;
            --search-input-border: #ccc;
            --search-input-focus-border: #1c62b9;
        }
        body.dark {
            --primary-background: #0f0f0f;
            --secondary-background: #212121;
            --primary-text: #f1f1f1;
            --secondary-text: #aaaaaa;
            --border-color: #3d3d3d;
            --hover-background: #3d3d3d;
            --input-background: #121212;
            --header-background: #212121;
            --header-text: #ffffff;
            --search-button-bg: #3d3d3d;
            --search-input-bg: #121212;
            --search-input-border: #303030;
            --search-input-focus-border: var(--yt-red);
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Arial', sans-serif;
            margin: 0;
            background-color: var(--primary-background);
            color: var(--primary-text);
            transition: background-color 0.2s, color 0.2s;
        }
        .header { display: flex; align-items: center; justify-content: space-between; padding: 0 16px 0 24px; height: 56px; background-color: var(--header-background); color: var(--header-text); }
        .logo-container { display: flex; align-items: center; gap: 8px; }
        .logo-container h1 { font-size: 20px; margin: 0; font-weight: 500; }
        .search-container-header { flex: 0 1 728px; display: flex; }
        #searchInput { width: 100%; padding: 10px 12px; font-size: 16px; border-radius: 40px 0 0 40px; border: 1px solid var(--search-input-border); background-color: var(--search-input-bg); color: var(--primary-text); }
        #searchInput:focus { border-color: var(--search-input-focus-border); outline: none; }
        #searchButton { padding: 0 24px; border-radius: 0 40px 40px 0; border: 1px solid var(--search-input-border); border-left: none; cursor: pointer; background-color: var(--hover-background); }
        #searchButton svg { fill: var(--primary-text); }
        .user-actions { display: flex; align-items: center; margin-left: 16px; }
        #darkModeToggle { background: none; border: none; cursor: pointer; padding: 8px; border-radius: 50%; display: flex; align-items: center; justify-content: center; }
        #darkModeToggle:hover { background-color: var(--yt-light-dark); }
        #darkModeToggle svg { fill: var(--header-text); }
        .moon-icon { display: none; }
        body.dark .sun-icon { display: none; }
        body.dark .moon-icon { display: block; }
        .page-container { display: flex; flex-direction: column; padding: 24px; max-width: 1440px; margin: 0 auto; }
        @media (min-width: 1024px) {
            .page-container { 
                display: grid; 
                grid-template-columns: 1fr 402px; 
                gap: 24px; 
                align-items: flex-start; 
                max-width: none; /* Remove width constraint for wide screens */
                padding: 24px 48px; /* More padding on very wide screens */
            }
        }
        @media (min-width: 1440px) {
            .page-container {
                padding: 24px 120px; /* Even more padding on ultra-wide screens */
            }
        }
        @media (min-width: 1800px) {
            .page-container {
                /* Keep the same grid structure - don't expand sidebar */
                padding: 24px 160px;
            }
        }
        .main-content { flex: 1; min-width: 0; }
        @media (min-width: 1024px) { 
            .main-content { 
                grid-column: 1 / 2; 
                grid-row: 1 / 2; 
                /* Limit width based on viewport height to prevent video from extending below fold */
                max-width: calc((100vh - 200px) * 16 / 9);
                /* 200px accounts for header (~56px) + padding + controls + margins */
            } 
        }
        @media (min-width: 1024px) and (min-height: 800px) {
            .main-content {
                /* More generous on taller screens */
                max-width: calc((100vh - 150px) * 16 / 9);
            }
        }
        @media (min-width: 1024px) and (min-height: 1000px) {
            .main-content {
                /* Even more generous on very tall screens */
                max-width: calc((100vh - 120px) * 16 / 9);
            }
        }
        .sidebar { width: 100%; max-width: 402px; margin: 24px auto 0 auto; }
        @media (min-width: 1024px) { 
            .sidebar { 
                grid-column: 2 / 3; 
                grid-row: 1 / 3; 
                width: 402px; 
                margin: 0; 
                flex-shrink: 0; 
            } 
        }
        /* Remove the ultra-wide sidebar expansion - keep it consistent */
        .sidebar-section { background-color: var(--secondary-background); border: 1px solid var(--border-color); border-radius: 12px; padding: 16px; margin-bottom: 16px; }
        .sidebar-section h2, .sidebar-section h3 { margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 8px; margin-bottom: 12px; color: var(--primary-text); }
        .player-container { width: 100%; aspect-ratio: 16 / 9; background-color: #000; border-radius: 12px; overflow: hidden; position: relative; }
        #player { width: 100%; height: 100%; }
        #results, #queueList { list-style: none; padding: 0; max-height: 300px; overflow-y: auto; }
        
        /* Make search section match video player + controls height - responsive approach */
        @media (min-width: 1024px) and (max-width: 1300px) {
            .sidebar-section:first-child {
                height: clamp(400px, 50vw, 600px);
                display: flex;
                flex-direction: column;
            }
            .sidebar-section:first-child #results {
                flex: 1;
                max-height: none;
                overflow-y: auto;
                min-height: 0;
            }
            .sidebar-section:first-child h2 {
                flex-shrink: 0;
            }
        }
        
        @media (min-width: 1301px) {
            .main-content {
                --video-area-height: auto;
            }
            
            .sidebar-section:first-child {
                height: calc(min(calc(100vw - 450px), calc((100vh - 200px) * 16 / 9)) * 9 / 16 + 60px);
                max-height: calc((100vh - 200px) + 60px);
                min-height: 450px;
                display: flex;
                flex-direction: column;
            }
            .sidebar-section:first-child #results {
                flex: 1;
                max-height: none;
                overflow-y: auto;
                min-height: 0;
            }
            .sidebar-section:first-child h2 {
                flex-shrink: 0;
            }
        }
        #results li, #queueList li { display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; border-radius: 4px; }
        #results li:hover, #queueList li:hover { background-color: var(--hover-background); }
        #results img, #queueList img { width: 120px; height: 67px; object-fit: cover; border-radius: 4px; flex-shrink: 0; }
        .video-info { flex-grow: 1; display: flex; justify-content: space-between; align-items: center; gap: 8px; min-width: 0; }
        .video-title { font-weight: 500; color: var(--primary-text); white-space: normal; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; }
        .video-duration { font-size: 12px; color: var(--secondary-text); margin-top: 4px; }
        .shuffle-btn { width: 100%; margin-bottom: 12px; padding: 8px 16px; font-size: 13px; background-color: var(--hover-background); color: var(--primary-text); border: 1px solid var(--border-color); border-radius: 8px; cursor: pointer; transition: background-color 0.2s; }
        .shuffle-btn:hover:not(:disabled) { background-color: var(--yt-light-dark); }
        .shuffle-btn:disabled { opacity: 0.5; cursor: not-allowed; }
        body.dark .shuffle-btn { background-color: var(--yt-light-dark); }
        body.dark .shuffle-btn:hover:not(:disabled) { background-color: #3a3a3a; }
        .playlist-item { border-left: 3px solid #ff0000; }
        .playlist-header { padding: 12px; background-color: var(--hover-background); border-radius: 8px; margin-bottom: 8px; }
        .playlist-header h3 { margin: 0 0 4px 0; font-size: 16px; color: var(--primary-text); }
        .playlist-header p { margin: 0 0 8px 0; font-size: 13px; color: var(--secondary-text); }
        .playlist-actions { display: flex; gap: 8px; }
        .play-all-btn, .queue-all-btn { padding: 8px 16px; font-size: 13px; background-color: #ff0000; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 500; }
        .queue-all-btn { background-color: transparent; color: var(--primary-text); border: 1px solid var(--border-color); }
        .play-all-btn:hover { background-color: #cc0000; }
        .queue-all-btn:hover { background-color: var(--hover-background); }
        .queue-btn, .remove-btn { padding: 6px 12px; font-size: 12px; flex-shrink: 0; background-color: var(--hover-background); color: var(--primary-text); border: 1px solid var(--border-color); border-radius: 18px; cursor: pointer; }
        body.dark .queue-btn, body.dark .remove-btn { background-color: var(--yt-light-dark); }
        .user-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .user-container { background: var(--secondary-background); color: var(--primary-text); padding: 24px; border-radius: 12px; text-align: center; }
        .user-container input { background-color: var(--input-background); color: var(--primary-text); border: 1px solid var(--border-color); border-radius: 8px; padding: 8px; margin: 0 8px; }
        #inviteLink { 
            font-size: 14px; 
            background-color: var(--input-background); 
            color: var(--primary-text); 
            border: 1px solid var(--border-color); 
            padding: 8px; 
            border-radius: 8px; 
            width: calc(100% - 16px);
            font-family: monospace; /* Better for URLs */
            word-break: break-all; /* Ensure long URLs wrap properly */
        }
        #createInviteBtn { width: 100%; margin-bottom: 10px;}
        .invite-row { display: flex; gap: 8px; margin-top: 8px; align-items: center; }
        .invite-row #inviteLink { width: auto; flex: 1; min-width: 0; }
        .invite-row button { padding: 8px 12px; }
        #userList { list-style-type: none; padding-left: 0; }
        #userList li { background-color: var(--primary-background); padding: 8px 12px; border-radius: 4px; margin-bottom: 5px; }
        .status { text-align: center; font-weight: bold; padding: 12px; border-radius: 6px; margin-top: 10px; }
        .status.connected { background-color: #d1e7dd; color: #0f5132; }
        .status.disconnected { background-color: #f8d7da; color: #842029; }
        .status.connecting { background-color: #fff3cd; color: #664d03; }
        button { background-color: var(--yt-red); color: white; padding: 10px 16px; border: none; border-radius: 40px; cursor: pointer; font-size: 14px; font-weight: 500; transition: background-color 0.2s; }
        button:hover { background-color: var(--yt-red-hover); }
        
        /* Medium desktop layout - safer grid for 1024-1300px */
        @media (min-width: 1024px) and (max-width: 1300px) {
            .page-container { 
                display: grid; 
                grid-template-columns: 1fr 380px; 
                gap: 20px; 
                align-items: flex-start;
                max-width: 1280px;
                margin: 0 auto;
                padding: 20px;
            }
        }
        
        /* Large desktop layout - full width optimization for 1300px+ */
        @media (min-width: 1301px) {
            .page-container { 
                display: grid; 
                grid-template-columns: minmax(800px, min(calc(100vw - 450px), calc((100vh - 200px) * 16 / 9))) 402px; 
                gap: 24px; 
                align-items: flex-start;
                justify-content: center;
                max-width: none;
                margin: 0 auto;
                padding: 20px;
            }
        }
        .player-controls { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; margin-top: 16px; background-color: var(--secondary-background); border: 1px solid var(--border-color); border-radius: 12px; }
        .video-title-toolbar { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: bold; font-size: 16px; padding-right: 16px; }
        #theaterModeBtn { background: none; border: 1px solid var(--border-color); color: var(--primary-text); padding: 8px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 50; flex-shrink: 0; }
        #theaterModeBtn:hover { background-color: var(--hover-background); }
        #theaterModeBtn svg { stroke: var(--primary-text); }
        #skipVideoBtn { background: none; border: 1px solid var(--border-color); color: var(--primary-text); padding: 8px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 50; flex-shrink: 0; margin-right: 8px; }
        #skipVideoBtn:hover { background-color: var(--hover-background); }
        #skipVideoBtn svg { stroke: var(--primary-text); }
        #skipVideoBtn:disabled { opacity: 0.5; cursor: not-allowed; }
        #skipVideoBtn:disabled:hover { background-color: transparent; }
        body.theater-mode .page-container { 
            display: block !important; 
            grid-template-columns: none !important;
            position: fixed; 
            top: 0; 
            left: 0; 
            width: 100vw; 
            height: 100vh; 
            background-color: #000; 
            z-index: 500; 
            padding: 0; 
            margin: 0; 
            gap: 0;
        }
        body.theater-mode .main-content { 
            position: static;
            width: 100%; 
            height: 100%; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            padding: 0;
            margin: 0;
        }
        body.theater-mode .player-container { 
            width: 100vw; 
            height: 100vh; 
            border-radius: 0; 
            padding-bottom: 0 !important;
            position: fixed;
            top: 0;
            left: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
        }
        body.theater-mode .player-container #player {
            width: 100vw !important;
            height: 100vh !important;
            max-width: none !important;
            max-height: none !important;
            position: static;
        }
        body.theater-mode .player-container #player iframe {
            width: 100vw !important;
            height: 100vh !important;
            position: static !important;
            top: 0 !important;
            left: 0 !important;
            margin: 0 !important;
            padding: 0 !important;
            border: none !important;
        }
        /* Hide the toolbar in theater mode */
        body.theater-mode .player-controls { display: none; }
        body.theater-mode .header, body.theater-mode .sidebar, body.theater-mode .page-container > .main-content ~ * { display: none; }
        .expand-icon { display: block; }
        .close-icon { display: none; }
        body.theater-mode .expand-icon { display: none; }
        body.theater-mode .close-icon { display: block; }
        .hidden { display: none !important; }

        /* Centered close button for theater mode */
        #theaterCloseBtn {
            position: fixed;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            padding: 0;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.25);
            background-color: rgba(0,0,0,0.6);
            color: #fff;
            cursor: pointer;
            backdrop-filter: blur(4px);
            /* fade behavior */
            opacity: 0;
            pointer-events: none;
            transition: opacity 180ms ease-in-out;
        }
        body.dark #theaterCloseBtn { border-color: rgba(255,255,255,0.25); }

        /* When theater UI should be visible */
        body.theater-mode.theater-ui-visible #theaterCloseBtn {
            opacity: 1;
            pointer-events: auto;
        }

        /* Transparent hover sensor to detect mouse movement over iframe */
        #theaterHoverSensor {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 96px; /* small strip */
            background: transparent;
            z-index: 1000; /* just under the close button */
            display: none;
        }
        body.theater-mode #theaterHoverSensor { display: block; }

        /* Up Next overlay */
        .upnext-overlay {
            position: absolute;
            inset: 0;
            z-index: 1002; /* above iframe and sensors */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 16px;
            background: linear-gradient(180deg, rgba(0,0,0,0.65), rgba(0,0,0,0.85));
            color: #fff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 180ms ease-in-out;
            padding: 16px;
            text-align: center;
        }
        .upnext-overlay.active {
            opacity: 1;
            pointer-events: auto; /* block clicks to YouTube suggestions */
        }
        /* Ensure overlay captures clicks above the player iframe */
        .player-container.overlay-active #player,
        .player-container.overlay-active #player iframe {
            pointer-events: none !important;
        }

        /* Up Next grid layout */
        .upnext-title { font-size: 20px; font-weight: 600; }
        .upnext-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 12px;
            width: 100%;
            max-width: 1100px;
            padding: 0 12px;
        }
        @media (min-width: 640px) {
            .upnext-grid { grid-template-columns: repeat(3, 1fr); }
        }
        @media (min-width: 1024px) {
            .upnext-grid { grid-template-columns: repeat(4, 1fr); }
        }
        .upnext-item {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 10px;
            overflow: hidden;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            text-align: left;
            transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
        }
        .upnext-item:hover {
            transform: translateY(-2px);
            background: rgba(255,255,255,0.12);
            box-shadow: 0 6px 20px rgba(0,0,0,0.35);
        }
        .upnext-item:focus {
            outline: 2px solid rgba(255,255,255,0.35);
            outline-offset: -2px;
        }
        .upnext-thumb {
            width: 100%;
            aspect-ratio: 16 / 9;
            object-fit: cover;
            display: block;
            background: #000;
        }
        .upnext-info {
            padding: 8px 10px 10px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .upnext-title-line {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .upnext-meta {
            font-size: 12px;
            color: rgba(255,255,255,0.8);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
    </style>
</head>
<body>

<div class="user-modal" id="userModal">
    <div class="user-container">
        <h2>Welcome to YouTube Party</h2>
        <p>Please enter your name to join or start a party.</p>
        <input type="text" id="userName" placeholder="Enter your name...">
        <button id="setNameBtn" disabled>Continue</button>
    </div>
</div>

<div id="mainContent" class="hidden">
    <div class="header">
        <div class="logo-container">
            <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="white" focusable="false"><path d="M10 16.5l6-4.5-6-4.5v9zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></svg>
            <h1>YouTube Party</h1>
        </div>
        <div class="search-container-header">
            <input type="text" id="searchInput" placeholder="Search for a YouTube video...">
            <button id="searchButton">
                <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" focusable="false"><path d="M20.87 20.17l-5.59-5.59C16.35 13.35 17 11.75 17 10c0-3.87-3.13-7-7-7s-7 3.13-7 7 3.13 7 7 7c1.75 0 3.35-.65 4.58-1.71l5.59 5.59.71-.71zM10 16c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"></path></svg>
            </button>
        </div>
        <div class="user-actions">
            <button id="darkModeToggle" title="Toggle dark mode">
                <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
            </button>
        </div>
    </div>
    
    <div class="page-container">
        <div class="main-content">
            <div class="player-container"><div id="player"></div>
                <!-- Up Next overlay -->
                <div id="upNextOverlay" class="upnext-overlay" aria-hidden="true">
                    <div class="upnext-title">Up next</div>
                    <div id="upNextList" class="upnext-grid"></div>
                    <div class="upnext-actions">
                        <button id="upNextReplayBtn" class="upnext-btn" title="Replay current video">Replay</button>
                        <button id="upNextCloseBtn" class="upnext-btn" title="Close">Close</button>
                    </div>
                    <div style="font-size:12px;opacity:.8;">Suggestions appear here when the queue is empty.</div>
                </div>
            </div>
            <div class="player-controls">
                <div id="videoTitle" class="video-title-toolbar">No video loaded</div>
                <div style="display: flex; gap: 8px;">
                    <button id="skipVideoBtn" title="Skip to Next Video" disabled>
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5,4 15,12 5,20"></polygon><line x1="19" y1="5" x2="19" y2="19"></line></svg>
                    </button>
                    <button id="theaterModeBtn" title="Theater Mode">
                        <svg class="expand-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                        <svg class="close-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                    </button>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="sidebar-section">
                <h2>Search</h2>
                <ul id="results"></ul>
            </div>
            
            <div class="sidebar-section">
                <h2>Queue</h2>
                <button id="shuffleQueueBtn" class="shuffle-btn" title="Shuffle queue order">ðŸ”€ Shuffle Queue</button>
                <ul id="queueList"></ul>
            </div>

            <div class="sidebar-section">
                <h2>Party Sync</h2>
                <div id="connectionManagement">
                    <button id="createInviteBtn">Create Invite Link</button>
                    <!-- Inline invite link + Copy button -->
                    <div class="invite-row hidden" id="inviteRow">
                        <input type="text" id="inviteLink" readonly>
                        <button id="copyInviteBtn" aria-label="Copy invite link" title="Copy to clipboard">Copy</button>
                    </div>
                </div>
                <h3>Connected Users</h3>
                <ul id="userList"></ul>
                <div id="connectionStatus" class="status disconnected">Status: Disconnected</div>
            </div>
        </div>

    </div>
</div>

<!-- Transparent sensor to detect mouse movement near top in theater mode -->
<div id="theaterHoverSensor" aria-hidden="true"></div>

<!-- Centered close button (only used in theater mode) -->
<button id="theaterCloseBtn" aria-label="Exit Theater Mode" title="Exit Theater Mode">
    <!-- X icon -->
    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" focusable="false">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
</button>

<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-functions-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-auth-compat.js"></script>
<script src="https://www.youtube.com/iframe_api"></script>

<script>
    // --- DARK MODE LOGIC ---
    const darkModeToggle = document.getElementById('darkModeToggle');
    if (localStorage.getItem('theme') === 'dark') {
        document.body.classList.add('dark');
    }
    darkModeToggle.addEventListener('click', () => {
        document.body.classList.toggle('dark');
        if (document.body.classList.contains('dark')) {
            localStorage.setItem('theme', 'dark');
        } else {
            localStorage.setItem('theme', 'light');
        }
    });

    // --- CONFIGURATION ---
    const firebaseConfig = {
        apiKey: "AIzaSyActKLRV4ldSsS1dKNwkXXdKblnwG0s654", 
        authDomain: "partysync-17cd5.firebaseapp.com",
        projectId: "partysync-17cd5",
        storageBucket: "partysync-17cd5.appspot.com",
        messagingSenderId: "294351433712",
        appId: "1:294351433712:web:826470510443b924a6b735",
        measurementId: "G-PF73SF4VGY"
    };

    // --- INITIALIZE FIREBASE ---
    const app = firebase.initializeApp(firebaseConfig);
    const db = app.firestore();

    // --- DOM ELEMENTS ---
    const userModal = document.getElementById('userModal');
    const userNameInput = document.getElementById('userName');
    const setNameBtn = document.getElementById('setNameBtn');
    const mainContent = document.getElementById('mainContent');
    const searchButton = document.getElementById('searchButton');
    const searchInput = document.getElementById('searchInput');
    const resultsList = document.getElementById('results');
    const queueList = document.getElementById('queueList');
    const skipVideoBtn = document.getElementById('skipVideoBtn');
    const shuffleQueueBtn = document.getElementById('shuffleQueueBtn');
    const connectionStatus = document.getElementById('connectionStatus');
    const createInviteBtn = document.getElementById('createInviteBtn');
    const inviteLinkInput = document.getElementById('inviteLink');
    const inviteRow = document.getElementById('inviteRow');
    const copyInviteBtn = document.getElementById('copyInviteBtn');
    const userList = document.getElementById('userList');
    const videoTitleElement = document.getElementById('videoTitle');

    // --- APP STATE ---
    let myName = '';
    let player;
    let isHost = false;
    let partyId = '';
    let myAuthId = null; 
    let currentHostId = '';
    const peerConnections = {};
    const dataChannels = {};
    let partyDocRef;
    let videoQueue = [];
    let isSyncingFromHost = false;
    let lastPlayerState = -1;
    let officialVideoDuration = 0;
    let hostHeartbeatInterval;
    let connectionKeepaliveInterval;
    let connectionMonitorInterval;
    const CONNECTION_KEEPALIVE_INTERVAL = 45000; // 45 seconds
    const CONNECTION_MONITOR_INTERVAL = 10000; // 10 seconds
    let lastKeepaliveReceived = {}; // Track last keepalive from each peer
    let intentToAutoPlay = false;
    let localUserList = {};
    let lastReverseSyncRequest = 0; // Track last time we requested guest positions
    let guestReadyStates = {}; // Track which guests have correct duration loaded
    // Track the currently loaded videoId
    let currentVideoId = null;

    // WebRTC configuration (enhanced for stability)
    const rtcConfig = {
        iceServers: [
            { urls: ['stun:stun.l.google.com:19302','stun:stun1.l.google.com:19302','stun:stun2.l.google.com:19302'] },
            // Add more STUN servers for redundancy
            { urls: 'stun:stun.services.mozilla.com' },
            { urls: 'stun:stun.stunprotocol.org:3478' }
        ],
        iceCandidatePoolSize: 4, // Increased for better connectivity
        iceTransportPolicy: 'all',
        // Add bundle policy for better connection stability
        bundlePolicy: 'balanced',
        // Add RTC configuration for better keepalive
        rtcpMuxPolicy: 'require'
    };

    // Helpful mapping for logging YT state numbers
    const YT_STATE = {
        [-1]: 'UNSTARTED',
        [0]: 'ENDED',
        [1]: 'PLAYING',
        [2]: 'PAUSED',
        [3]: 'BUFFERING',
        [5]: 'CUED',
    };

    // Up Next overlay elements
    const upNextOverlay = document.getElementById('upNextOverlay');
    const upNextList = document.getElementById('upNextList');
    const upNextCloseBtn = document.getElementById('upNextCloseBtn');
    const upNextReplayBtn = document.getElementById('upNextReplayBtn');
    let upNextActive = false;

    // Also grab the container to toggle a helper class
    const playerContainer = document.querySelector('.player-container');

    function showUpNextOverlay() {
        // Move overlay to be last child to sit above everything
        if (upNextOverlay.parentElement) {
            upNextOverlay.parentElement.appendChild(upNextOverlay);
        }
        upNextOverlay.classList.add('active');
        upNextOverlay.setAttribute('aria-hidden', 'false');
        // Inline fallbacks in case of CSS specificity issues
        upNextOverlay.style.opacity = '1';
        upNextOverlay.style.pointerEvents = 'auto';
        if (playerContainer) playerContainer.classList.add('overlay-active');
        upNextActive = true;
        console.log('[UpNext] Overlay shown');
    }
    function hideUpNextOverlay() {
        upNextOverlay.classList.remove('active');
        upNextOverlay.setAttribute('aria-hidden', 'true');
        upNextOverlay.style.opacity = '';
        upNextOverlay.style.pointerEvents = '';
        if (playerContainer) playerContainer.classList.remove('overlay-active');
        upNextActive = false;
        console.log('[UpNext] Overlay hidden');
    }
    async function populateUpNextSuggestions() {
        try {
            if (!player || !player.getVideoData) return;
            const data = player.getVideoData();
            const title = data?.title || '';
            const vid = data?.video_id || currentVideoId;
            currentVideoId = vid || currentVideoId;

            upNextList.innerHTML = '<div style="grid-column:1/-1;opacity:.8;">Loading suggestionsâ€¦</div>';

            // Call the Cloud Function to search by the current title (approximate related)
            const searchYoutubeFunction = app.functions('us-central1').httpsCallable('searchYoutube');
            const res = await searchYoutubeFunction({ query: title || 'YouTube' });
            const items = (res.data?.items || [])
                .map(it => {
                    const id = typeof it.id === 'object' ? it.id.videoId : it.id;
                    return {
                        videoId: id,
                        title: it.snippet?.title || '',
                        channel: it.snippet?.channelTitle || '',
                        thumb: it.snippet?.thumbnails?.medium?.url || it.snippet?.thumbnails?.default?.url
                    };
                })
                .filter(v => v.videoId && v.videoId !== vid)
                .slice(0, 8);

            if (!items.length) {
                upNextList.innerHTML = '<div style="grid-column:1/-1;opacity:.8;">No suggestions found.</div>';
                return;
            }

            upNextList.innerHTML = '';
            for (const it of items) {
                const card = document.createElement('div');
                card.className = 'upnext-item';
                card.setAttribute('role', 'button');
                card.setAttribute('tabindex', '0');
                card.setAttribute('aria-label', `Play ${it.title}`);
                card.innerHTML = `
                    <img class="upnext-thumb" src="${it.thumb}" alt="">
                    <div class="upnext-info">
                        <div class="upnext-title-line" title="${it.title}">${it.title}</div>
                        <div class="upnext-meta" title="${it.channel}">${it.channel}</div>
                    </div>
                `;
                const playSelected = () => {
                    hideUpNextOverlay();
                    handleUserAction({ type: 'NEW_VIDEO', videoId: it.videoId, autoPlay: true });
                };
                card.addEventListener('click', playSelected);
                card.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        playSelected();
                    }
                });
                upNextList.appendChild(card);
            }
        } catch (e) {
            console.warn('Failed to load suggestions', e);
            upNextList.innerHTML = '<div style="grid-column:1/-1;opacity:.8;">Failed to load suggestions.</div>';
        }
    }

    upNextCloseBtn.addEventListener('click', hideUpNextOverlay);
    upNextReplayBtn.addEventListener('click', () => {
        if (currentVideoId) {
            hideUpNextOverlay();
            handleUserAction({ type: 'NEW_VIDEO', videoId: currentVideoId, autoPlay: true });
        }
    });

    // Intercept YouTube suggestion clicks that try to open a new tab and play them in-app instead
    (function installYouTubeOpenInterceptor() {
        const originalOpen = window.open ? window.open.bind(window) : null;
        function extractYouTubeVideoId(urlLike) {
            try {
                const urlStr = String(urlLike);
                const re = /(?:v=|\/shorts\/|youtu\.be\/)([A-Za-z0-9_-]{11})/;
                const m = urlStr.match(re);
                if (m && m[1]) return m[1];
                const u = new URL(urlStr, window.location.href);
                const host = u.hostname.replace(/^www\./, '');
                if (host.endsWith('youtu.be')) {
                    const parts = u.pathname.split('/').filter(Boolean);
                    if (parts[0] && parts[0].length === 11) return parts[0];
                }
                if (host.endsWith('youtube.com')) {
                    if (u.pathname.startsWith('/shorts/')) {
                        const id = u.pathname.split('/')[2] || u.pathname.split('/')[1];
                        if (id && id.length === 11) return id;
                    }
                    const v = u.searchParams.get('v');
                    if (v && v.length === 11) return v;
                }
            } catch (_) {}
            return null;
        }
        window.open = function(url, target, features) {
            const vid = extractYouTubeVideoId(url);
            if (vid) {
                try {
                    handleUserAction({ type: 'NEW_VIDEO', videoId: vid, autoPlay: true });
                    return null;
                } catch (e) {
                    return originalOpen ? originalOpen(url, target, features) : null;
                }
            }
            return originalOpen ? originalOpen(url, target, features) : null;
        };
    })();

    // --- AUTHENTICATION & APP START ---
    firebase.auth().onAuthStateChanged(user => {
        if (user) {
            myAuthId = user.uid;
            console.log("User signed in with UID:", myAuthId);
            setNameBtn.disabled = false;
        } else {
            myAuthId = null;
            setNameBtn.disabled = true;
        }
    });

    setNameBtn.disabled = true;
    firebase.auth().signInAnonymously().catch((error) => {
        console.error("Anonymous sign-in failed:", error);
        alert("Could not connect to the service. Please refresh the page.");
    });

    // --- INITIALIZATION ---
    setNameBtn.addEventListener('click', () => {
        const name = userNameInput.value.trim();
        if (name && myAuthId) {
            myName = name;
            userModal.classList.add('hidden');
            mainContent.classList.remove('hidden');
            initApp();
        } else if (!name) {
            alert('Please enter a name.');
        } else {
            alert('Could not verify connection. Please refresh the page.');
        }
    });

    function initApp() {
        const urlParams = new URLSearchParams(window.location.search);
        partyId = urlParams.get('party');
        if (partyId) {
            isHost = false;
            createInviteBtn.classList.add('hidden');
            // Detect if you opened the guest link as the same signed-in user as the host
            (async () => {
                try {
                    const partySnap = await db.collection('parties').doc(partyId).get();
                    const hostIdFromDoc = partySnap.data()?.hostId;
                    if (hostIdFromDoc && hostIdFromDoc === myAuthId) {
                        console.warn('[JOIN] Same UID as host. Use a different browser profile/incognito for the guest.');
                        alert('You are joining with the same account as the host. Open the invite in a different browser or an incognito window so the guest has a different UID.');
                    }
                } catch (e) {
                    console.warn('Could not verify hostId before joining:', e);
                } finally {
                    joinParty();
                }
            })();
        } else {
            isHost = true;
            startHostHeartbeat();
            updateSkipButtonState(); // Update button states for host
        }
        // Enhanced leaving detection - multiple methods for reliability
        const sendLeavingMessage = () => {
            const data = { type: 'USER_LEAVING' };
            Object.values(dataChannels).forEach(channel => {
                if (channel && channel.readyState === 'open') {
                    try {
                        channel.send(JSON.stringify(data));
                    } catch (e) {
                        console.warn('Error sending leaving message:', e);
                    }
                }
            });
        };

        // Method 1: beforeunload event
        window.addEventListener('beforeunload', sendLeavingMessage);
        
        // Method 2: pagehide event (more reliable on mobile)
        window.addEventListener('pagehide', sendLeavingMessage);
        
        // Method 3: visibilitychange - only used for UI feedback, not disconnection
        let hiddenTimeout;
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                console.log('[UI] Tab hidden - continuing to sync in background');
            } else {
                console.log('[UI] Tab visible again');
            }
        });

        // Add periodic cleanup for stale connections (every 2 minutes)
        setInterval(() => {
            if (isHost) {
                let removedUsers = [];
                
                // Check for disconnected peer connections
                Object.entries(peerConnections).forEach(([peerId, pc]) => {
                    if (pc.connectionState === 'closed' || pc.connectionState === 'failed') {
                        console.log(`[CLEANUP] Removing stale connection: ${peerId}`);
                        
                        // Clean up
                        delete peerConnections[peerId];
                        delete dataChannels[peerId];
                        delete localUserList[peerId];
                        delete guestTimePositions[peerId]; // Clean up position tracking
                        removedUsers.push(peerId);
                        
                        // Clean up Firestore
                        if (partyDocRef) {
                            partyDocRef.collection('guests').doc(peerId).delete().catch(error => 
                                console.error("Error removing stale guest document:", error)
                            );
                        }
                    }
                });
                
                // If we removed anyone, update the user list
                if (removedUsers.length > 0) {
                    console.log(`[CLEANUP] Removed ${removedUsers.length} stale connections`);
                    
                    const users = { [myAuthId]: { name: myName } };
                    Object.entries(peerConnections).forEach(([id, pc]) => {
                        if (pc.peerName) users[id] = { name: pc.peerName };
                    });
                    localUserList = users;
                    broadcastData({ type: 'USER_LIST', users });
                    updateUserList(localUserList);
                }
                
                // Also clean up old guest time positions (older than 30 seconds)
                const now = Date.now();
                Object.keys(guestTimePositions).forEach(guestId => {
                    if (now - guestTimePositions[guestId].timestamp > 30000) {
                        delete guestTimePositions[guestId];
                    }
                });
            }
        }, 120000); // 2 minutes

    }
    


    // Simple duration-based ad detection
    function isAdPlaying() {
        if (!player || typeof player.getDuration !== 'function') return false;
        
        const currentDuration = player.getDuration();
        const currentTime = player.getCurrentTime();
        const playerState = player.getPlayerState();
        
        // Only use duration comparison method
        if (officialVideoDuration > 0) {
            const durationMismatch = Math.abs(currentDuration - officialVideoDuration) > 30;
            
            if (durationMismatch) {
                console.log(`[AD-DETECT] Duration mismatch detected: ${currentDuration}s vs expected ${officialVideoDuration}s`);
                return true;
            }
        }
        
        return false;
    }
    

    
    function getExpectedCurrentTime() {
        // For hosts: use their current position
        if (isHost) {
            return player.getCurrentTime();
        }
        
        // For guests: estimate based on when the video started playing
        // This is a fallback - in practice, sync will handle this
        if (officialVideoDuration > 0) {
            return Math.min(player.getCurrentTime(), officialVideoDuration);
        }
        
        return 0;
    }
    
    function getExpectedGuestTime() {
        // For guests, estimate where they should be based on the last sync from host
        if (isHost) return player.getCurrentTime(); // Hosts are authoritative
        
        // Use the last known sync time as a baseline
        if (window.lastHostSyncTime && window.lastHostSyncTimestamp) {
            const timeSinceSync = (Date.now() - window.lastHostSyncTimestamp) / 1000;
            return window.lastHostSyncTime + timeSinceSync;
        }
        
        // Fallback to current position if no sync data
        return player.getCurrentTime();
    }
    

    

    


    // Timer-based ad detection for stuck loading states
    let adDetectionTimer = null;
    
    function startAdDetectionTimer() {
        // Clear any existing timer
        if (adDetectionTimer) {
            clearInterval(adDetectionTimer);
        }
        
        // Start checking for ads every 5 seconds during loading (less aggressive)
        adDetectionTimer = setInterval(() => {
            if (player) {
                const state = player.getPlayerState();
                
                // Only check for ads after initial loading period and if we detect actual ad indicators
                if (state === YT.PlayerState.BUFFERING || state === YT.PlayerState.UNSTARTED) {
                    // Get timing information to avoid interfering with normal loading
                    const videoLoadTime = window.lastVideoLoadTime || Date.now(); // Default to now if not set
                    const timeSinceVideoLoad = Date.now() - videoLoadTime;
                    const isInitialLoading = timeSinceVideoLoad < 10000; // First 10 seconds
                    
                    // Enhanced diagnostic information (less verbose during initial loading)
                    const duration = player.getDuration();
                    const currentTime = player.getCurrentTime();
                    const videoData = player.getVideoData();
                    
                    // Capture video duration if it's available and we don't have it yet (for hosts)
                    if (isHost && duration > 0 && (officialVideoDuration === 0 || Math.abs(duration - officialVideoDuration) > 1)) {
                        console.log(`[DURATION] Capturing video duration from timer: ${duration}s (was ${officialVideoDuration}s)`);
                        officialVideoDuration = duration;
                        broadcastData({ type: 'VIDEO_DURATION', duration: duration });
                    }
                    
                    // Simple duration-based detection during non-initial loading
                    if (!isInitialLoading) {
                        // Only check for ads if we have an expected duration to compare against
                        // If officialVideoDuration is 0, we're still loading, not seeing an ad
                        if (officialVideoDuration > 0) {
                            console.log(`[AD-DETECT] Checking during ${YT_STATE[state]} state`);
                            console.log(`[AD-DETECT] Player details: duration=${duration}, time=${currentTime}, videoId=${videoData?.video_id}`);
                            
                            // Duration-based ad detection: if duration is 0 or very different from expected
                            const durationMismatch = duration === 0 || Math.abs(duration - officialVideoDuration) > 30;
                            
                            if (durationMismatch) {
                                console.log(`[AD-DETECT] Duration mismatch detected - expected: ${officialVideoDuration}s, got: ${duration}s`);
                                
                                if (isHost) {
                                    console.log('[SYNC] Host detected ad based on duration, avoiding sync broadcasts');
                                } else {
                                    console.log(`[AD-DETECT] Guest detected ad based on duration, waiting for host sync`);
                                }
                            }
                        }
                    }
                } else if (state === YT.PlayerState.PLAYING) {
                    console.log('[AD-DETECT] Video playing, stopping timer');
                    
                    // Check if there's a pending INITIAL_SYNC from host migration
                    if (!isHost && window.pendingInitialSync) {
                        console.log('[SYNC] Ad finished, applying pending INITIAL_SYNC from host migration');
                        const pendingData = window.pendingInitialSync;
                        delete window.pendingInitialSync;
                        
                        // Apply the pending sync
                        setTimeout(() => {
                            if (player.getVideoData()?.video_id === pendingData.videoId) {
                                player.seekTo(pendingData.time, true);
                                if (pendingData.state === YT.PlayerState.PLAYING) {
                                    player.playVideo();
                                } else if (pendingData.state === YT.PlayerState.PAUSED) {
                                    player.pauseVideo();
                                }
                                console.log('[SYNC] Successfully applied pending sync after ad');
                            }
                        }, 500);
                    }
                    
                    // Host finished ad - request guest positions to sync forward if needed
                    if (isHost && currentTime < 5 && duration > 0 && Math.abs(duration - officialVideoDuration) < 2) {
                        console.log('[AD-RECOVERY] Host finished ad, requesting guest positions to catch up');
                        const requestData = { type: 'REQUEST_POSITION' };
                        Object.entries(dataChannels).forEach(([id, channel]) => {
                            if (id !== 'host' && channel && channel.readyState === 'open') {
                                channel.send(JSON.stringify(requestData));
                            }
                        });
                    }
                    
                    // Guest finished ad - will naturally sync to host's next TIME_UPDATE
                    if (!isHost && currentTime < 5) {
                        console.log('[AD-RECOVERY] Guest finished ad, will sync to host on next update');
                    }
                    
                    // Stop timer when video is playing normally
                    clearInterval(adDetectionTimer);
                    adDetectionTimer = null;
                }
            }
        }, 5000);
        
        // Clear timer after 30 seconds max
        setTimeout(() => {
            if (adDetectionTimer) {
                clearInterval(adDetectionTimer);
                adDetectionTimer = null;
                console.log('[AD-DETECT] Timer cleared after 30 seconds');
            }
        }, 30000);
    }
    
    // Check if all guests have loaded the video with correct duration, then auto-start
    function checkAllGuestsReadyAndAutoStart() {
        if (!isHost || !player) return;
        
        const hostDuration = player.getDuration();
        const hostState = player.getPlayerState();
        
        // Only auto-start if host has loaded but hasn't started playing yet
        if (hostDuration <= 0 || hostState === YT.PlayerState.PLAYING) {
            return;
        }
        
        const connectedGuests = Object.keys(dataChannels).filter(id => id !== 'host' && dataChannels[id]?.readyState === 'open');
        
        // If no guests, auto-start immediately
        if (connectedGuests.length === 0) {
            console.log('[AUTO-START] No guests connected, starting video');
            player.playVideo();
            return;
        }
        
        // Check if host has an ad
        const hostHasAd = isAdPlaying();
        
        if (hostHasAd) {
            // Host has ad - check if any guest is ready without an ad
            const guestsWithoutAds = connectedGuests.filter(guestId => {
                const guestState = guestReadyStates[guestId];
                return guestState && 
                       !guestState.hasAd &&
                       Math.abs(guestState.duration - officialVideoDuration) < 2 &&
                       guestState.videoId === currentVideoId;
            });
            
            if (guestsWithoutAds.length > 0) {
                console.log('[AUTO-START] Host has ad but guests ready, guests will start playing');
                // Broadcast start to guests without ads
                broadcastData({ 
                    type: 'STATE_CHANGE', 
                    state: YT.PlayerState.PLAYING, 
                    time: 0,
                    hostHasAd: true // Let guests know host has ad
                });
                return;
            } else {
                console.log('[AUTO-START] Host and all guests have ads, waiting...');
                return;
            }
        }
        
        // Host doesn't have ad - start playing if all guests without ads are ready
        const guestsWithoutAds = connectedGuests.filter(guestId => {
            const guestState = guestReadyStates[guestId];
            return guestState && !guestState.hasAd;
        });
        
        const allGuestsWithoutAdsReady = guestsWithoutAds.every(guestId => {
            const guestState = guestReadyStates[guestId];
            return guestState && 
                   Math.abs(guestState.duration - officialVideoDuration) < 2 &&
                   guestState.videoId === currentVideoId;
        });
        
        // If all guests without ads are ready (or all guests have ads), start
        if (guestsWithoutAds.length === 0 || allGuestsWithoutAdsReady) {
            console.log('[AUTO-START] Host ready, starting video (guests with ads will catch up later)');
            player.playVideo();
            // Clear ready states for next video
            guestReadyStates = {};
        }
    }
    
    // Guest recovery timer for ad issues

    


    // Enhanced TIME_UPDATE handling for ad detection
    function handleTimeUpdate() {
        if (!isHost || !player) return;
        
        // Check if ad is playing but don't try to skip it
        const adPlaying = isAdPlaying();
        if (adPlaying) {
            console.log('[SYNC] Ad detected during time update, avoiding sync');
            return; // Skip syncing during ads
        }
        
        const currentState = player.getPlayerState();
        const hostTime = player.getCurrentTime();
        
        // Broadcast time updates to guests for synchronization
        if (currentState === YT.PlayerState.PLAYING) {
            const videoData = player.getVideoData();
            broadcastData({ 
                type: 'TIME_UPDATE', 
                time: hostTime,
                duration: player.getDuration(),
                state: currentState,
                videoId: videoData ? videoData.video_id : currentVideoId
            });
        }
    }

    // --- THEATER MODE ---
    const theaterModeBtn = document.getElementById('theaterModeBtn');
    const theaterCloseBtn = document.getElementById('theaterCloseBtn');
    const theaterHoverSensor = document.getElementById('theaterHoverSensor');
    let theaterUiHideTimer;

    function showTheaterUiTemporarily(delayMs = 3000) {
        document.body.classList.add('theater-ui-visible');
        clearTimeout(theaterUiHideTimer);
        theaterUiHideTimer = setTimeout(() => {
            document.body.classList.remove('theater-ui-visible');
        }, delayMs);
    }

    function theaterActivityPing() {
        if (!document.body.classList.contains('theater-mode')) return;
        showTheaterUiTemporarily();
    }

    function disableTheaterUi() {
        clearTimeout(theaterUiHideTimer);
        document.body.classList.remove('theater-ui-visible');
        document.removeEventListener('mousemove', theaterActivityPing);
        document.removeEventListener('keydown', theaterActivityPing);
        document.removeEventListener('wheel', theaterActivityPing, { passive: true });
        document.removeEventListener('touchstart', theaterActivityPing, { passive: true });
        theaterHoverSensor.removeEventListener('mousemove', theaterActivityPing);
        theaterHoverSensor.removeEventListener('mouseenter', theaterActivityPing);
        theaterCloseBtn.removeEventListener('click', exitTheaterMode);
    }

    function enableTheaterUi() {
        showTheaterUiTemporarily();
        // Re-show on user activity (mouse over doc, top sensor, keys, wheel, touch)
        document.addEventListener('mousemove', theaterActivityPing);
        document.addEventListener('keydown', theaterActivityPing);
        document.addEventListener('wheel', theaterActivityPing, { passive: true });
        document.addEventListener('touchstart', theaterActivityPing, { passive: true });
        theaterHoverSensor.addEventListener('mousemove', theaterActivityPing);
        theaterHoverSensor.addEventListener('mouseenter', theaterActivityPing);
        theaterCloseBtn.addEventListener('click', exitTheaterMode);
    }

    function exitTheaterMode() {
        document.body.classList.remove('theater-mode');
        theaterModeBtn.title = 'Theater Mode';
        disableTheaterUi();
    }

    theaterModeBtn.addEventListener('click', () => {
        document.body.classList.toggle('theater-mode');
        const inTheaterMode = document.body.classList.contains('theater-mode');
        theaterModeBtn.title = inTheaterMode ? 'Exit Theater Mode' : 'Theater Mode';
        if (inTheaterMode) {
            enableTheaterUi();
        } else {
            disableTheaterUi();
        }
    });

    // Allow Esc to exit theater mode
    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && document.body.classList.contains('theater-mode')) {
            exitTheaterMode();
        }
    });

    // --- YOUTUBE API ---
    window.onYouTubeIframeAPIReady = () => {
        player = new YT.Player('player', {
            videoId: '',
            playerVars: {
                rel: 0,
                playsinline: 1,
                modestbranding: 1,
                origin: window.location.origin
            },
            events: { 
                'onStateChange': onPlayerStateChange,
                'onReady': () => {
                    console.log('[YT] Player ready');
                    
                    // Fix Chrome bug: Add allow="autoplay" to iframe
                    const iframe = player.getIframe();
                    if (iframe) {
                        iframe.setAttribute('allow', 'autoplay; encrypted-media; picture-in-picture');
                        console.log('[YT] Added allow attribute to iframe for autoplay support');
                    }
                    
                    playerReady = true;
                    processPendingMessages();
                }
            }
        });
    };
    
    // Helper function to process buffered messages
    function processPendingMessages() {
        if (pendingMessages.length > 0) {
            console.log(`[YT] Processing ${pendingMessages.length} buffered messages`);
            const messagesToProcess = [...pendingMessages];
            pendingMessages = []; // Clear the buffer first to prevent recursion
            
            messagesToProcess.forEach(({ data, senderId }) => {
                try {
                    handleReceivedData(data, senderId);
                } catch (error) {
                    console.error('[YT] Error processing buffered message:', error);
                }
            });
        }
    }

    // Helper function to format ISO 8601 duration (PT1H2M10S) to readable format (1:02:10)
    function formatDuration(isoDuration) {
        if (!isoDuration) return '';
        const match = isoDuration.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
        if (!match) return '';
        
        const hours = parseInt(match[1]) || 0;
        const minutes = parseInt(match[2]) || 0;
        const seconds = parseInt(match[3]) || 0;
        
        if (hours > 0) {
            return `${hours}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        } else {
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
    }

    searchButton.addEventListener('click', searchYouTube);
    searchInput.addEventListener('keypress', e => e.key === 'Enter' && searchYouTube());
    skipVideoBtn.addEventListener('click', skipToNextVideo);
    shuffleQueueBtn.addEventListener('click', shuffleQueue);

    // Shuffle queue function (host only)
    function shuffleQueue() {
        if (!isHost) {
            console.log('[QUEUE] Only host can shuffle queue');
            return;
        }
        
        if (videoQueue.length === 0) {
            console.log('[QUEUE] Queue is empty, nothing to shuffle');
            return;
        }
        
        // Fisher-Yates shuffle algorithm
        const shuffled = [...videoQueue];
        for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
        }
        
        videoQueue = shuffled;
        console.log('[QUEUE] Shuffled queue with', videoQueue.length, 'videos');
        
        // Broadcast shuffled queue to all guests
        const queueUpdateData = { type: 'QUEUE_UPDATE', queue: videoQueue };
        Object.entries(dataChannels).forEach(([id, channel]) => {
            if (id !== 'host' && channel && channel.readyState === 'open') {
                channel.send(JSON.stringify(queueUpdateData));
            }
        });
        
        // Update host's own queue UI
        updateQueueUI();
    }

    async function searchYouTube() {
		const query = searchInput.value;
		if (!query) return;

		// Regular expressions for YouTube URLs
		const youtubeVideoRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([\w-]{11})/;
		const youtubePlaylistRegex = /(?:https?:\/\/)?(?:www\.)?youtube\.com\/.*[?&]list=([\w-]+)/;
		
		const videoMatch = query.match(youtubeVideoRegex);
		const playlistMatch = query.match(youtubePlaylistRegex);
		
		let payload = {};
		if (playlistMatch) {
			// If it's a playlist URL, fetch the playlist
			const playlistId = playlistMatch[1];
			payload = { playlistId: playlistId };
			console.log("YouTube Playlist URL detected. Fetching playlist:", playlistId);
		} else if (videoMatch) {
			// If it's a video URL, fetch the video
			const videoId = videoMatch[1];
			payload = { videoId: videoId };
			console.log("YouTube Video URL detected. Fetching by video ID:", videoId);
		} else {
			// Otherwise, it's a regular search query - search for both videos and playlists
			payload = { query: query, searchType: 'video,playlist' };
			console.log("Performing keyword search for:", query);
		}

		const searchYoutubeFunction = app.functions('us-central1').httpsCallable('searchYoutube');
		try {
			const result = await searchYoutubeFunction(payload);
			
			// Handle playlist response differently
			if (result.data.playlist) {
				// Single playlist with its items
				displayPlaylistResult(result.data.playlist, result.data.items);
			} else {
				// Mixed search results (videos and/or playlists)
				displayResults(result.data.items || []);
			}
		} catch (error) {
			console.error("Error calling Cloud Function:", error);
			alert("Could not fetch results. Check the console for details.");
		}
	}

    function displayResults(items) {
		resultsList.innerHTML = items.length ? '' : '<li>No results found.</li>';
		items.forEach(item => {
			// Check if this is a video or playlist
			const isPlaylist = item.kind === 'youtube#playlist';
			
			if (isPlaylist) {
				// Display playlist
				const playlistId = item.id;
				const title = item.snippet.title;
				const thumbnailUrl = item.snippet.thumbnails.default.url;
				const videoCount = item.contentDetails ? item.contentDetails.itemCount : 0;

				const li = document.createElement('li');
				li.dataset.playlistId = playlistId;
				li.classList.add('playlist-item');
				li.innerHTML = `<img src="${thumbnailUrl}" alt="${title}"><div class="video-info"><div><div class="video-title" title="Load Playlist">${title}</div><div class="video-duration">ðŸ“‹ ${videoCount} videos</div></div><button class="queue-btn">Queue All</button></div>`;
				
				const clickableElements = [li.querySelector('img'), li.querySelector('.video-title')];
				clickableElements.forEach(el => el.addEventListener('click', () => {
					if (playlistId) {
						loadPlaylist(playlistId, true); // true = play first video immediately
					}
				}));

				li.querySelector('.queue-btn').addEventListener('click', (e) => {
					e.stopPropagation();
					if (playlistId) {
						loadPlaylist(playlistId, false); // false = add all to queue
					}
				});
				
				resultsList.appendChild(li);
			} else {
				// Display video
				const videoId = (typeof item.id === 'object') ? item.id.videoId : item.id;
				const title = item.snippet.title;
				const thumbnailUrl = item.snippet.thumbnails.default.url;
				const duration = item.contentDetails ? formatDuration(item.contentDetails.duration) : '';

				const li = document.createElement('li');
				li.dataset.videoId = videoId;
				li.innerHTML = `<img src="${thumbnailUrl}" alt="${title}"><div class="video-info"><div><div class="video-title" title="Play Now">${title}</div>${duration ? `<div class="video-duration">${duration}</div>` : ''}</div><button class="queue-btn">Add</button></div>`;
				
				const clickableElements = [li.querySelector('img'), li.querySelector('.video-title')];
				clickableElements.forEach(el => el.addEventListener('click', () => {
					if (videoId) {
						handleUserAction({ type: 'NEW_VIDEO', videoId: videoId, autoPlay: true });
					}
				}));

				li.querySelector('.queue-btn').addEventListener('click', (e) => {
					e.stopPropagation();
					if (videoId) {
						const videoData = { videoId, title, thumbnailUrl, duration };
						handleUserAction({ type: 'ADD_TO_QUEUE', video: videoData });
					}
				});
				
				resultsList.appendChild(li);
			}
		});
	}

	// Display a single playlist URL result with its videos
	async function displayPlaylistResult(playlist, playlistItems) {
		resultsList.innerHTML = '';
		
		// Show playlist header
		const playlistHeader = document.createElement('div');
		playlistHeader.className = 'playlist-header';
		playlistHeader.innerHTML = `
			<h3>${playlist.snippet.title}</h3>
			<p>${playlist.contentDetails.itemCount} videos</p>
			<div class="playlist-actions">
				<button class="play-all-btn">â–¶ Play All</button>
				<button class="queue-all-btn">+ Queue All</button>
			</div>
		`;
		resultsList.appendChild(playlistHeader);

		playlistHeader.querySelector('.play-all-btn').addEventListener('click', () => {
			loadPlaylist(playlist.id, true);
		});
		
		playlistHeader.querySelector('.queue-all-btn').addEventListener('click', () => {
			loadPlaylist(playlist.id, false);
		});

		// Get all video IDs and fetch full details including duration
		const videoIds = playlistItems.map(item => item.snippet.resourceId.videoId).join(',');
		const searchYoutubeFunction = app.functions('us-central1').httpsCallable('searchYoutube');
		
		try {
			const videoDetailsResult = await searchYoutubeFunction({ videoId: videoIds });
			const videoDetails = videoDetailsResult.data.items || [];
			
			// Create a map of videoId to duration
			const durationMap = {};
			videoDetails.forEach(video => {
				const duration = video.contentDetails ? formatDuration(video.contentDetails.duration) : '';
				durationMap[video.id] = duration;
			});

			// Show individual videos from playlist with duration
			playlistItems.forEach(item => {
				const videoId = item.snippet.resourceId.videoId;
				const title = item.snippet.title || 'Untitled Video';
				
				// Safe thumbnail extraction with fallback
				let thumbnailUrl = '';
				if (item.snippet.thumbnails) {
					thumbnailUrl = item.snippet.thumbnails.default?.url || 
					              item.snippet.thumbnails.medium?.url || 
					              item.snippet.thumbnails.high?.url || '';
				}
				
				const duration = durationMap[videoId] || '';

				const li = document.createElement('li');
				li.dataset.videoId = videoId;
				li.innerHTML = `<img src="${thumbnailUrl}" alt="${title}"><div class="video-info"><div><div class="video-title" title="Play Now">${title}</div>${duration ? `<div class="video-duration">${duration}</div>` : ''}</div><button class="queue-btn">Add</button></div>`;
				
				const clickableElements = [li.querySelector('img'), li.querySelector('.video-title')];
				clickableElements.forEach(el => el.addEventListener('click', () => {
					handleUserAction({ type: 'NEW_VIDEO', videoId: videoId, autoPlay: true });
				}));

				li.querySelector('.queue-btn').addEventListener('click', (e) => {
					e.stopPropagation();
					const videoData = { videoId, title, thumbnailUrl, duration };
					handleUserAction({ type: 'ADD_TO_QUEUE', video: videoData });
				});
				
				resultsList.appendChild(li);
			});
		} catch (error) {
			console.error('Error fetching video details for playlist:', error);
			// Fallback: show videos without duration
			playlistItems.forEach(item => {
				const videoId = item.snippet.resourceId.videoId;
				const title = item.snippet.title || 'Untitled Video';
				
				// Safe thumbnail extraction with fallback
				let thumbnailUrl = '';
				if (item.snippet.thumbnails) {
					thumbnailUrl = item.snippet.thumbnails.default?.url || 
					              item.snippet.thumbnails.medium?.url || 
					              item.snippet.thumbnails.high?.url || '';
				}

				const li = document.createElement('li');
				li.dataset.videoId = videoId;
				li.innerHTML = `<img src="${thumbnailUrl}" alt="${title}"><div class="video-info"><div><div class="video-title" title="Play Now">${title}</div></div><button class="queue-btn">Add</button></div>`;
				
				const clickableElements = [li.querySelector('img'), li.querySelector('.video-title')];
				clickableElements.forEach(el => el.addEventListener('click', () => {
					handleUserAction({ type: 'NEW_VIDEO', videoId: videoId, autoPlay: true });
				}));

				li.querySelector('.queue-btn').addEventListener('click', (e) => {
					e.stopPropagation();
					const videoData = { videoId, title, thumbnailUrl };
					handleUserAction({ type: 'ADD_TO_QUEUE', video: videoData });
				});
				
				resultsList.appendChild(li);
			});
		}
	}

	// Load playlist and either play first video or add all to queue
	async function loadPlaylist(playlistId, playFirst) {
		console.log('Loading playlist:', playlistId, 'playFirst:', playFirst);
		
		const searchYoutubeFunction = app.functions('us-central1').httpsCallable('searchYoutube');
		try {
			const result = await searchYoutubeFunction({ playlistId: playlistId });
			const playlistItems = result.data.items || [];
			
			if (playlistItems.length === 0) {
				alert('This playlist is empty or unavailable.');
				return;
			}

			// Get all video IDs from the playlist
			const videoIds = playlistItems.map(item => item.snippet.resourceId.videoId).join(',');
			
			// Fetch full video details including duration
			const videoDetailsResult = await searchYoutubeFunction({ videoId: videoIds });
			const videoDetails = videoDetailsResult.data.items || [];
			
			// Create a map of videoId to duration
			const durationMap = {};
			videoDetails.forEach(video => {
				const duration = video.contentDetails ? formatDuration(video.contentDetails.duration) : '';
				durationMap[video.id] = duration;
			});

			if (playFirst) {
				// Play the first video immediately
				const firstVideo = playlistItems[0];
				const firstVideoId = firstVideo.snippet.resourceId.videoId;
				handleUserAction({ type: 'NEW_VIDEO', videoId: firstVideoId, autoPlay: true });
				
				// Add the rest to the queue with duration
				for (let i = 1; i < playlistItems.length; i++) {
					const item = playlistItems[i];
					const videoId = item.snippet.resourceId.videoId;
					
					// Safe thumbnail extraction with fallback
					let thumbnailUrl = '';
					if (item.snippet.thumbnails) {
						thumbnailUrl = item.snippet.thumbnails.default?.url || 
						              item.snippet.thumbnails.medium?.url || 
						              item.snippet.thumbnails.high?.url || '';
					}
					
					const videoData = {
						videoId: videoId,
						title: item.snippet.title || 'Untitled Video',
						thumbnailUrl: thumbnailUrl,
						duration: durationMap[videoId] || ''
					};
					handleUserAction({ type: 'ADD_TO_QUEUE', video: videoData });
				}
				console.log(`Loaded playlist: playing first video, queued ${playlistItems.length - 1} more`);
			} else {
				// Add all videos to queue with duration
				playlistItems.forEach(item => {
					const videoId = item.snippet.resourceId.videoId;
					
					// Safe thumbnail extraction with fallback
					let thumbnailUrl = '';
					if (item.snippet.thumbnails) {
						thumbnailUrl = item.snippet.thumbnails.default?.url || 
						              item.snippet.thumbnails.medium?.url || 
						              item.snippet.thumbnails.high?.url || '';
					}
					
					const videoData = {
						videoId: videoId,
						title: item.snippet.title || 'Untitled Video',
						thumbnailUrl: thumbnailUrl,
						duration: durationMap[videoId] || ''
					};
					handleUserAction({ type: 'ADD_TO_QUEUE', video: videoData });
				});
				console.log(`Added ${playlistItems.length} videos from playlist to queue`);
			}
		} catch (error) {
			console.error('Error loading playlist:', error);
			alert('Could not load playlist. Check the console for details.');
		}
	}

    // --- WEBRTC & FIREBASE SIGNALING ---
    createInviteBtn.addEventListener('click', async () => {
        if (!myAuthId) return alert("Cannot create party, not connected.");
        isHost = true;
        partyId = crypto.randomUUID();
        currentHostId = myAuthId;
        updateSkipButtonState(); // Update button states for host
        const url = `${window.location.href.split('?')[0]}?party=${partyId}`;
        inviteLinkInput.value = url;
        // Show inline row with copy button
        inviteRow.classList.remove('hidden');
        copyInviteBtn.disabled = false;
        copyInviteBtn.textContent = 'Copy';

        createInviteBtn.disabled = true;
        partyDocRef = db.collection('parties').doc(partyId);
        try {
            await partyDocRef.set({
                hostId: myAuthId,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            console.log('[HOST] Created party doc', partyId);
        } catch (e) {
            console.error('[HOST] Failed to create party doc:', e);
            alert('Could not create party in Firestore. Check Firestore rules and console.');
            return;
        }
        listenForGuests();
        startHostHeartbeat();
    });

    async function joinParty() {
        if (!myAuthId) return alert("Cannot join party, not connected.");
        partyDocRef = db.collection('parties').doc(partyId);
        const guestDocRef = partyDocRef.collection('guests').doc(myAuthId);
        console.log('[JOIN] Starting joinParty for', myAuthId, 'party:', partyId);

        const pc = createPeerConnection('host');
        const candidateBuffer = [];
        let candidateTimer = null;

        // Keep refs on the pc for ICE restarts
        pc._guestDocRef = guestDocRef;
        pc._guestGuestCandidatesRef = guestDocRef.collection('guestCandidates');
        pc._guestHostCandidatesRef = guestDocRef.collection('hostCandidates');

        dataChannels['host'] = pc.createDataChannel('sync-channel');
        console.log('[JOIN] Created data channel to host');
        configureDataChannel('host', dataChannels['host']);

        const guestCandidatesRef = pc._guestGuestCandidatesRef;

        pc.onicecandidate = async (event) => {
            if (event.candidate) {
                try {
                    await guestCandidatesRef.add(event.candidate.toJSON());
                    console.log('[JOIN] Sent guest ICE candidate');
                } catch (e) {
                    console.error('[JOIN] Failed to write guest ICE candidate:', e);
                }
            } else {
                console.log('[JOIN] ICE gathering complete');
            }
        };

        try {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            console.log('[JOIN] Created offer');
            await guestDocRef.set({ offer, name: myName });
            console.log('[JOIN] Wrote offer to Firestore');
        } catch (e) {
            console.error('[JOIN] Failed to create/send offer:', e);
            alert('Could not join the party (offer failed). Check console for details.');
            return;
        }

        guestDocRef.onSnapshot(async (snapshot) => {
            const data = snapshot.data();
            if (!data) return;
            
            // Apply the host's answer only once and only in have-local-offer state
            if (data.answer && !pc._answerApplied && pc.signalingState === 'have-local-offer') {
                try {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                    pc._answerApplied = true;
                    console.log('[JOIN] Set remote description (answer) from host');
                    candidateBuffer.forEach(c => pc.addIceCandidate(new RTCIceCandidate(c)).catch(err => console.error('[JOIN] addIceCandidate (buffer) failed:', err)));
                    candidateBuffer.length = 0;
                } catch (e) {
                    console.error('[JOIN] Failed to set remote description:', e);
                }
            }
        });
        
        // Start monitoring host activity as a backup to WebRTC state detection
        startHostActivityMonitoring();

        pc._guestHostCandidatesRef.onSnapshot(snapshot => {
            snapshot.docChanges().forEach(change => {
                if (change.type === 'added') {
                    const candidate = change.doc.data();
                    if (pc.currentRemoteDescription) {
                        pc.addIceCandidate(new RTCIceCandidate(candidate))
                          .then(() => console.log('[JOIN] Added host ICE candidate'))
                          .catch(err => console.error('[JOIN] addIceCandidate failed:', err));
                    } else {
                        console.log('[JOIN] Buffering host ICE candidate (no remote desc yet)');
                        candidateBuffer.push(candidate);
                    }
                }
            });
        });
    }

    function listenForGuests() {
        console.log('[HOST] Listening for guests on party', partyId);
        partyDocRef.collection('guests').onSnapshot(async snapshot => {
            for (const change of snapshot.docChanges()) {
                const doc = change.doc;
                const guestId = doc.id;
                const data = doc.data() || {};
                if (change.type === 'added') {
                    const { offer, name } = data;
                    console.log('[HOST] Guest added:', guestId, 'name:', name);
                    // If someone joins with same UID as the host, refuse (they share auth state)
                    if (guestId === myAuthId) {
                        console.warn('[HOST] Ignoring guest with same UID as host. Use a different browser/incognito for guests.');
                        continue;
                    }
                    if (peerConnections[guestId]) continue;

                    try {
                        const guestDocRef = doc.ref;
                        const pc = createPeerConnection(guestId, name);
                        pc._hostGuestDocRef = guestDocRef;

                        pc.ondatachannel = event => {
                            console.log('[HOST] Data channel from guest', guestId);
                            dataChannels[guestId] = event.channel;
                            configureDataChannel(guestId, event.channel, name);
                        };

                        pc.onicecandidate = async (event) => {
                            if (event.candidate) {
                                try {
                                    await guestDocRef.collection('hostCandidates').add(event.candidate.toJSON());
                                    console.log('[HOST] Sent host ICE candidate to', guestId);
                                } catch (e) {
                                    console.error('[HOST] Failed to write host ICE candidate:', e);
                                }
                            } else {
                                console.log('[HOST] ICE gathering complete for', guestId);
                            }
                        };

                        await pc.setRemoteDescription(new RTCSessionDescription(offer));
                        console.log('[HOST] Set remote description (offer) from', guestId);
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        console.log('[HOST] Created answer for', guestId);
                        await guestDocRef.update({ answer });
                        console.log('[HOST] Wrote answer for', guestId);

                        guestDocRef.collection('guestCandidates').onSnapshot(snap => {
                            snap.docChanges().forEach(ch => {
                                if (ch.type === 'added') {
                                    const cand = ch.doc.data();
                                    pc.addIceCandidate(new RTCIceCandidate(cand))
                                      .then(() => console.log('[HOST] Added guest ICE candidate', guestId))
                                      .catch(err => console.error('[HOST] addIceCandidate failed:', err));
                                }
                            });
                        });
                    } catch (e) {
                        console.error('[HOST] Error handling new guest', guestId, e);
                    }
                } else if (change.type === 'modified') {
                    // Handle ICE-restart offers from guest with throttling
                    try {
                        const pc = peerConnections[guestId];
                        if (!pc) continue;
                        
                        const now = Date.now();
                        
                        // Throttle restart responses to prevent loops
                        if (pc._lastRestartResponse && (now - pc._lastRestartResponse) < 5000) {
                            console.log('[HOST] Restart response throttled for', guestId);
                            continue;
                        }
                        
                        if (data.offer && data.restartedAt && pc.signalingState !== 'have-remote-offer') {
                            // Only process if this is a newer restart attempt
                            if (!pc._lastProcessedRestart || data.restartedAt > pc._lastProcessedRestart) {
                                console.log('[HOST] Guest', guestId, 'sent ICE-restart offer; answering...');
                                await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                                const answer = await pc.createAnswer();
                                await pc.setLocalDescription(answer);
                                await doc.ref.update({ answer });
                                console.log('[HOST] Wrote restart answer for', guestId);
                                
                                pc._lastRestartResponse = now;
                                pc._lastProcessedRestart = data.restartedAt;
                            } else {
                                console.log('[HOST] Ignoring duplicate restart from', guestId);
                            }
                        }
                    } catch (e) {
                        console.error('[HOST] Failed to process modified guest doc:', guestId, e);
                    }
                }
            }
        });
    }

    function createPeerConnection(peerId, peerName) {
        // Remove this problematic check that's blocking guest connections
        // if (hostMigrationInProgress) {
        //     console.log('[RTC] Skipping connection creation during migration');
        //     return null;
        // }
        
        const pc = new RTCPeerConnection(rtcConfig);
        peerConnections[peerId] = pc;
        pc.peerName = peerName;
        pc.peerId = peerId;

        let disconnectTimer = null;

        pc.onconnectionstatechange = () => {
            // Throttle logging to reduce spam
            const now = Date.now();
            if (!pc._lastStateLog || (now - pc._lastStateLog) > 2000) {
                console.log(`[RTC:${peerId}] connectionState=`, pc.connectionState);
                pc._lastStateLog = now;
            }
            updateConnectionStatus();
            
            // Handle host disconnection only when connection is truly dead
            if (peerId === 'host' && !isHost) {
                const state = pc.connectionState;
                
                // Only trigger migration for 'failed' or 'closed' states, not 'disconnected'
                // 'disconnected' can be temporary, but 'failed' means the connection is truly dead
                if (state === 'failed' || state === 'closed') {
                    console.warn(`[RTC:host] Host connection definitively lost (${state}), scheduling migration check`);
                    
                    // Reset migration flag if it was stuck
                    if (hostMigrationInProgress) {
                        console.warn('[MIGRATION] Resetting stuck migration flag');
                        hostMigrationInProgress = false;
                    }
                    
                    // Start migration after checking connection state again and testing ping
                    setTimeout(() => {
                        const currentState = pc.connectionState;
                        const iceState = pc.iceConnectionState;
                        console.log(`[MIGRATION] Host connection final check - Conn: ${currentState}, ICE: ${iceState}`);
                        
                        // Only migrate if connection is still definitively failed AND we can't ping
                        if (!hostMigrationInProgress && 
                            (currentState === 'failed' || currentState === 'closed')) {
                            
                            // Try one final ping test before giving up
                            const hostChannel = dataChannels['host'];
                            if (hostChannel && hostChannel.readyState === 'open') {
                                console.log('[MIGRATION] Attempting final ping test before migration');
                                try {
                                    hostChannel.send(JSON.stringify({ type: 'PING', timestamp: Date.now() }));
                                    // Give it 3 seconds to respond before migrating
                                    setTimeout(() => {
                                        if (!hostMigrationInProgress && (pc.connectionState === 'failed' || pc.connectionState === 'closed')) {
                                            console.log('[MIGRATION] Final ping test failed, starting migration');
                                            handleHostDisconnection();
                                        } else {
                                            console.log('[MIGRATION] Host responded to final ping, connection recovered');
                                        }
                                    }, 3000);
                                } catch (e) {
                                    console.log('[MIGRATION] Final ping failed, connection definitely dead');
                                    handleHostDisconnection();
                                }
                            } else {
                                console.log('[MIGRATION] Data channel closed, starting migration');
                                handleHostDisconnection();
                            }
                        } else {
                            console.log('[MIGRATION] Host connection recovered or migration already in progress');
                        }
                    }, 2000); // Increased delay to allow for recovery
                }
            }
        };

        pc.oniceconnectionstatechange = () => {
            // Throttle logging
            const now = Date.now();
            if (!pc._lastIceStateLog || (now - pc._lastIceStateLog) > 2000) {
                console.log(`[RTC:${peerId}] iceConnectionState=`, pc.iceConnectionState);
                pc._lastIceStateLog = now;
            }
            
            if (pc.iceConnectionState === 'disconnected') {
                clearTimeout(disconnectTimer);
                // Increased timeout and added connection stability checks
                disconnectTimer = setTimeout(() => {
                    // Only attempt recovery if we're still disconnected and channel isn't working
                    if (pc.iceConnectionState === 'disconnected') {
                        const channel = dataChannels[peerId];
                        const channelWorking = channel && channel.readyState === 'open';
                        
                        if (!channelWorking) {
                            console.warn(`[RTC:${peerId}] Still disconnected after 15s, attempting ICE restart`);
                            attemptGuestIceRestart(pc);
                        } else {
                            console.log(`[RTC:${peerId}] Disconnected but data channel still works, monitoring...`);
                        }
                    }
                }, 15000); // Increased from 5000ms to 15000ms for stability
            } else if (pc.iceConnectionState === 'failed') {
                console.warn(`[RTC:${peerId}] ICE failed. You likely need a TURN server.`);
            } else if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
                clearTimeout(disconnectTimer);
            }
        };
        // Remove excessive signaling state logging completely
        pc.onsignalingstatechange = () => {
            // Only log significant state changes
            if (pc.signalingState === 'stable' || pc.signalingState === 'closed') {
                console.log(`[RTC:${peerId}] signalingState=`, pc.signalingState);
            }
        };
        // Remove ICE gathering state logging completely
        pc.onicegatheringstatechange = () => {
            // Only log completion
            if (pc.iceGatheringState === 'complete') {
                console.log(`[RTC:${peerId}] iceGatheringState= complete`);
            }
        };
        return pc;
    }
    
    // Guest-side ICE restart helper
    async function attemptGuestIceRestart(pc) {
        // Only guests restart toward the host
        if (isHost || pc.peerId !== 'host') return;
        if (!pc._guestDocRef) return;
        
        // Add throttling to prevent restart loops
        const now = Date.now();
        if (pc._lastRestartAttempt && (now - pc._lastRestartAttempt) < 10000) {
            console.log('[JOIN] ICE restart throttled (last attempt too recent)');
            return;
        }
        
        if (pc._iceRestartInProgress) {
            console.log('[JOIN] ICE restart already in progress; skipping.');
            return;
        }
        if (pc.signalingState === 'closed') {
            console.warn('[JOIN] ICE restart skipped; connection already closed.');
            return;
        }
        
        // Check connection state - only restart if truly failed/disconnected
        if (pc.connectionState !== 'failed' && pc.iceConnectionState !== 'failed' && pc.iceConnectionState !== 'disconnected') {
            console.log('[JOIN] ICE restart skipped; connection not in failed state');
            return;
        }
        
        pc._iceRestartInProgress = true;
        pc._lastRestartAttempt = now;
        
        try {
            console.log('[JOIN] Attempting ICE restart...');
            // Create a new offer with iceRestart
            const offer = await pc.createOffer({ iceRestart: true });
            await pc.setLocalDescription(offer);
            // Clear old answer so host will respond with a fresh answer
            await pc._guestDocRef.update({
                offer,
                restartedAt: now,
                answer: firebase.firestore.FieldValue.delete()
            });
            console.log('[JOIN] Wrote restart offer');
        } catch (e) {
            console.error('[JOIN] ICE restart failed:', e);
        } finally {
            pc._iceRestartInProgress = false;
        }
    }

    // Utility: delete all docs in a subcollection (candidates)
    async function clearCollection(colRef) {
        try {
            const snap = await colRef.get();
            if (snap.empty) return;
            const batch = db.batch();
            snap.forEach(doc => batch.delete(doc.ref));
            await batch.commit();
        } catch (e) {
            console.warn('clearCollection failed:', e);
        }
    }

    function resetPartyState() {
        console.log("Resetting party state...");
        for (const peerId in peerConnections) {
            if (peerConnections[peerId]) {
                peerConnections[peerId].close();
            }
        }
        Object.keys(peerConnections).forEach(key => delete peerConnections[key]);
        Object.keys(dataChannels).forEach(key => delete dataChannels[key]);
        userList.innerHTML = '';
        localUserList = {};
        window.migrationInProgress = false;
    }

    // Add this variable declaration around line 580, with the other state variables:
let hostMigrationInProgress = false;
let hostMigrationTimeout = null;
let hostElectionLock = null;
let playerReady = false;
let pendingMessages = [];
let loadingNewVideo = false;
let guestTimePositions = {}; // Track guest positions for reverse sync


    function handleUserAction(data) {
        
        // If guest is loading a NEW_VIDEO, load it locally first to prevent sync conflicts
        if (!isHost && data.type === 'NEW_VIDEO') {
            console.log('[DATA] Guest loading video locally first:', data.videoId);
            loadingNewVideo = true;
            currentVideoId = data.videoId;
            window.lastVideoLoadTime = Date.now(); // Track load time for ad detection
            hideUpNextOverlay();
            updateVideoTitle();
            
            // Load the video immediately for the guest
            if (player && typeof player.loadVideoById === 'function') {
                player.loadVideoById(data.videoId);
                
                // Start ad detection timer for both hosts and guests
                startAdDetectionTimer();
                
                // Guest waits for host sync instead of starting recovery timer
                
                // Process any buffered messages after a short delay to allow video to load
                setTimeout(() => {
                    processPendingMessages();
                }, 1000);
                
                if (data.autoPlay) {
                    // Set a flag to auto-play once loaded
                    setTimeout(() => {
                        if (player.getPlayerState() === YT.PlayerState.CUED) {
                            player.playVideo();
                        }
                    }, 1000);
                }
            }
        }
        
        if (isHost) {
            broadcastData(data);
        } else {
            sendRequestToHost(data);
        }
    }

    function sendRequestToHost(data) {
        if (isHost) return;

        if (data.type === 'STATE_CHANGE') {
            // Check if we should suppress this state change due to recent sync from host
            // Allow state changes during new video loading
            if (loadingNewVideo) {
                console.log('[DATA] Allowing state change during video loading');
                // Clear the flag once we start playing the new video
                if (data.state === YT.PlayerState.PLAYING) {
                    loadingNewVideo = false;
                }
            }
        }

        const requestData = { ...data, type: `REQUEST_${data.type}` };
        const hostChannel = dataChannels['host'];
        if (hostChannel && hostChannel.readyState === 'open') {
            hostChannel.send(JSON.stringify(requestData));
        } else {
            console.warn("Host channel not open; cannot send request.");
        }
    }

    function broadcastData(data) {
        // If host is broadcasting, include ad status
        if (isHost && player && (data.type === 'STATE_CHANGE' || data.type === 'TIME_UPDATE')) {
            data.hostHasAd = isAdPlaying();
            if (data.hostHasAd) {
                console.log('[HOST-AD] Including ad status in broadcast');
            }
        }
        
        handleReceivedData(data, 'local');
        Object.entries(dataChannels).forEach(([id, channel]) => {
            if (id !== 'host' && channel && channel.readyState === 'open') {
                channel.send(JSON.stringify(data));
            }
        });
    }

    function configureDataChannel(peerId, channel, peerName = '') {
        // Enhanced data channel monitoring
        channel._lastStateLog = 0;
        
        // Monitor channel state changes
        const checkChannelState = () => {
            const now = Date.now();
            if (now - channel._lastStateLog > 30000) { // Log every 30 seconds
                console.log(`[DC:${peerId}] readyState=${channel.readyState}, bufferedAmount=${channel.bufferedAmount}`);
                channel._lastStateLog = now;
            }
        };
        
        // Set up periodic channel health checks
        const channelHealthCheck = setInterval(() => {
            if (channel.readyState === 'closed') {
                clearInterval(channelHealthCheck);
                return;
            }
            checkChannelState();
            
            // Clear excessive buffer if it builds up
            if (channel.bufferedAmount > 1024 * 16) { // 16KB threshold
                console.warn(`[DC:${peerId}] High buffer: ${channel.bufferedAmount} bytes`);
            }
        }, 30000);
        
        channel.onopen = () => {
            console.log(`[DC:${peerId}] open`);
            hostMigrationInProgress = false; // Changed from window.migrationInProgress
            updateConnectionStatus();
            
            // Initialize keepalive tracking for this peer
            lastKeepaliveReceived[peerId] = Date.now();
            
            if (isHost) {
                const users = { [myAuthId]: { name: myName } };
                Object.entries(peerConnections).forEach(([id, pc]) => {
                    if (pc.peerName) users[id] = { name: pc.peerName };
                });
                broadcastData({ type: 'USER_LIST', users });
                channel.send(JSON.stringify({ type: 'HOST_INFO', hostId: myAuthId }));
                if (player && player.getPlayerState && player.getPlayerState() !== YT.PlayerState.UNSTARTED && player.getVideoData().video_id) {
                    const syncData = { type: 'INITIAL_SYNC', videoId: player.getVideoData().video_id, time: player.getCurrentTime(), state: player.getPlayerState(), duration: player.getDuration(), queue: videoQueue };
                    channel.send(JSON.stringify(syncData));
                } else {
                    broadcastData({ type: 'QUEUE_UPDATE', queue: videoQueue });
                }
            }
        };
        channel.onclose = () => {
            console.log(`[DC:${peerId}] close`);
            
            // Clean up keepalive tracking
            delete lastKeepaliveReceived[peerId];
            
            // Clear health check interval
            clearInterval(channelHealthCheck);
            
            if (peerId === 'host' && !isHost) {
                console.warn('[DC:host] Host data channel closed');
                
                // Don't immediately trigger migration - wait to see if it's temporary
                setTimeout(() => {
                    const pc = peerConnections['host'];
                    const connState = pc ? pc.connectionState : 'closed';
                    
                    console.log(`[DC:host] Delayed check - connection state: ${connState}`);
                    
                    // Only trigger migration if connection is truly failed and migration not already in progress
                    if (!hostMigrationInProgress && !isHost && 
                        (connState === 'failed' || connState === 'closed')) {
                        console.log('[DC:host] Host connection confirmed dead after delay, starting migration');
                        handleHostDisconnection();
                    } else {
                        console.log('[DC:host] Host connection recovered or migration already in progress');
                    }
                }, 5000); // Wait 5 seconds to see if connection recovers
                return;
            }
            
            // Clean up connections
            delete peerConnections[peerId];
            delete dataChannels[peerId];
            
            // Remove from local user list
            delete localUserList[peerId];
            
            // Clean up Firestore if we're the host
            if (isHost && partyDocRef) {
                partyDocRef.collection('guests').doc(peerId).delete().catch(error => 
                    console.error("Error removing guest document:", error)
                );
            }
            
            updateConnectionStatus();
            
            // Update and broadcast user list
            if (isHost) {
                const users = { [myAuthId]: { name: myName } };
                Object.entries(peerConnections).forEach(([id, pc]) => {
                    if (pc.peerName) users[id] = { name: pc.peerName };
                });
                localUserList = users;
                broadcastData({ type: 'USER_LIST', users });
            }
            
            // Update local UI for everyone
            updateUserList(localUserList);
        };
        channel.onmessage = event => {
            try { handleReceivedData(JSON.parse(event.data), peerId); }
            catch (e) { console.error(`[DC:${peerId}] bad message`, e, event.data); }
        };
    }

    function onPlayerStateChange(event) {
        const state = event.data;
        console.log('[YT] onPlayerStateChange:', state, `(${YT_STATE[state] || 'UNKNOWN'})`, {
            queueLen: videoQueue.length,
            hidden: document.hidden,
            currentVideoId,
        });

        // Handle video ending: either show "Up Next" or play next video in queue
        if (state === YT.PlayerState.ENDED) {
            if (videoQueue.length === 0) {
                // Show "Up Next" overlay when queue is empty
                if (!upNextActive) {
                    console.log('[UpNext] ENDED with empty queue â€” showing overlay');
                    showUpNextOverlay();
                    setTimeout(() => populateUpNextSuggestions(), 0);
                }
            } else if (isHost) {
                // Play next video in queue immediately (hosts only)
                console.log('[QUEUE] Video ended, playing next video from queue');
                const nextVideo = videoQueue.shift();
                hideUpNextOverlay();
                handleUserAction({ type: 'NEW_VIDEO', videoId: nextVideo.videoId, autoPlay: true });
                const queueUpdateData = { type: 'QUEUE_UPDATE', queue: videoQueue };
                broadcastData(queueUpdateData);
                return; // Exit early to avoid normal state processing
            } else {
                // For guests, don't send ENDED state if there are videos in queue
                // The host will handle queue progression
                if (videoQueue.length > 0) {
                    console.log('[GUEST] Video ended but queue exists - letting host handle progression');
                    return; // Don't send ENDED state to host
                }
            }
        }

        // Only hide overlay when playback resumes
        if (state === YT.PlayerState.PLAYING) {
            updateVideoTitle();
            hideUpNextOverlay();
        } else if (state === YT.PlayerState.CUED) {
            updateVideoTitle();
            
            // Capture video duration when video is cued (metadata available)
            if (isHost && player) {
                const duration = player.getDuration();
                if (duration > 0 && Math.abs(duration - officialVideoDuration) > 1) {
                    console.log(`[DURATION] Capturing video duration from CUED state: ${duration}s`);
                    officialVideoDuration = duration;
                    broadcastData({ type: 'VIDEO_DURATION', duration: duration });
                    
                    // Check if all guests are ready and auto-start
                    setTimeout(() => {
                        checkAllGuestsReadyAndAutoStart();
                    }, 1000); // Give guests a moment to report their ready state
                }
            }
            
            // Guest notifies host when video is loaded with correct duration
            if (!isHost && player) {
                const duration = player.getDuration();
                if (duration > 0 && officialVideoDuration > 0 && Math.abs(duration - officialVideoDuration) < 2) {
                    const guestHasAd = isAdPlaying();
                    console.log(`[GUEST-READY] Video loaded with correct duration: ${duration}s, hasAd: ${guestHasAd}, notifying host`);
                    const hostChannel = dataChannels['host'];
                    if (hostChannel && hostChannel.readyState === 'open') {
                        hostChannel.send(JSON.stringify({
                            type: 'GUEST_READY',
                            duration: duration,
                            videoId: currentVideoId,
                            hasAd: guestHasAd
                        }));
                    }
                }
            }
        }

        if (isHost && intentToAutoPlay && state === YT.PlayerState.CUED) {
            intentToAutoPlay = false;
            handleUserAction({ type: 'STATE_CHANGE', state: YT.PlayerState.PLAYING, time: 0, userInitiated: false });
            return;
        }

        // Detect in-iframe selection (e.g., end-screen click that navigates inside iframe)
        try {
            const vid = (player && typeof player.getVideoData === 'function') ? player.getVideoData().video_id : null;
            if (vid && currentVideoId && vid !== currentVideoId) {
                console.log('[YT] Detected in-iframe selection of new video:', vid);
                currentVideoId = vid;
                handleUserAction({ type: 'NEW_VIDEO', videoId: vid, autoPlay: true });
                return;
            }
        } catch (_) {}

        // Check for ads during buffering for hosts (but don't skip them)
        if (state === YT.PlayerState.BUFFERING && isHost && player) {
            console.log('[AD-DETECT] Checking for ads during buffering state');
            const adPlaying = isAdPlaying();
            if (adPlaying) {
                console.log('[SYNC] Ad detected during buffering, avoiding sync');
                return; // Skip syncing during ads
            }
        }

        // Ignore pure buffering (but after ad check above)
        if (state === YT.PlayerState.BUFFERING) return;

        // Suppress duplicate states EXCEPT allow ENDED to still propagate once (overlay handled above)
        if (state !== YT.PlayerState.ENDED && state === lastPlayerState) return;

        lastPlayerState = state;

        // For pause detection, check if anyone manually paused without sync
        if (state === YT.PlayerState.PAUSED) {
            console.log('[YT] Pause detected');
        } else if (state === YT.PlayerState.PLAYING) {
            console.log('[YT] Video playing, clearing manual pause flag');
            
            // Video playing successfully
            
            // Host ad/buffer recovery detection
            if (isHost && player) {
                const currentTime = player.getCurrentTime();
                const currentDuration = player.getDuration();
                const now = Date.now();
                
                // Check if this is a fresh video load (not an ad recovery)
                const videoLoadTime = window.lastVideoLoadTime || 0;
                const timeSinceLoad = now - videoLoadTime;
                const isFreshLoad = timeSinceLoad < 15000; // Within 15 seconds of load
                
                // If host is playing from near the beginning (0-5 seconds) but has guests
                // and the video has a reasonable duration, request guest positions
                // Only do this once per video load (cooldown of 20 seconds)
                // Don't do this for fresh video loads (to avoid false positives)
                if (!isFreshLoad && currentTime < 5 && currentDuration > 30 && 
                    Object.keys(dataChannels).length > 0 &&
                    (now - lastReverseSyncRequest) > 20000) {
                    console.log('[REVERSE-SYNC] Host may have restarted from ad, requesting guest positions');
                    lastReverseSyncRequest = now;
                    
                    // Request current positions from all guests
                    const requestData = { type: 'REQUEST_POSITION' };
                    Object.entries(dataChannels).forEach(([id, channel]) => {
                        if (id !== 'host' && channel && channel.readyState === 'open') {
                            channel.send(JSON.stringify(requestData));
                        }
                    });
                }
            }
            
            // Guest ad detection when starting to play (but don't try to skip)
            if (!isHost && player && officialVideoDuration > 0) {
                const adPlaying = isAdPlaying();
                if (adPlaying) {
                    console.log(`[GUEST-AD] Ad detected on playback start, guest will wait for sync`);
                    // Guest just waits for host to sync after ad ends
                }
            }
        }

        // Remove hidden tab pause suppression - we want videos to keep playing
        // regardless of tab focus state

        if (isHost && state === YT.PlayerState.PLAYING) {
            const duration = player.getDuration();
            if (Math.abs(duration - officialVideoDuration) > 1) {
                officialVideoDuration = duration;
                broadcastData({ type: 'VIDEO_DURATION', duration: duration });
            }
            
            // Check if ad is playing to avoid syncing during ads
            if (!isAdPlaying()) {
                const actionData = { type: 'STATE_CHANGE', state, time: player.getCurrentTime(), userInitiated: false };
                handleUserAction(actionData);
            } else {
                console.log('[SYNC] Ad detected during PLAYING state, skipping sync');
            }
        } else {
            // For guests, DON'T send automatic state changes to host
            // Guests should only sync FROM the host, not TO the host
            // The only exception is truly user-initiated actions (manual pause/play)
            if (!isHost) {
                console.log(`[GUEST] Ignoring automatic state change (${YT_STATE[state]}) - guests sync FROM host only`);
                return; // Don't send any automatic state changes from guests
            }
            
            const actionData = { type: 'STATE_CHANGE', state, time: player.getCurrentTime(), userInitiated: false };
            handleUserAction(actionData);
        }
    }

    function handleReceivedData(data, senderId) {
        // Improved player readiness check
        const isPlayerActuallyReady = playerReady && player && typeof player.getPlayerState === 'function';
        
        // Buffer messages if player isn't ready yet
        if (!isPlayerActuallyReady && (data.type.includes('VIDEO') || data.type === 'TIME_UPDATE' || data.type === 'STATE_CHANGE' || data.type === 'INITIAL_SYNC' || data.type === 'VIDEO_DURATION')) {
            console.log(`[DATA] Buffering ${data.type} - player not ready yet (playerReady: ${playerReady}, player: ${!!player})`);
            pendingMessages.push({ data, senderId });
            return;
        }
        
        // Additional safety check for specific player methods before use
        if (data.type === 'TIME_UPDATE' && (!player || typeof player.getCurrentTime !== 'function')) {
            console.log(`[DATA] Ignoring ${data.type} - player methods not available`);
            return;
        }
        
    // FIXED: Host should process guest requests AND apply them locally
    if (isHost && data.type.startsWith('REQUEST_')) {
        // Collect guest time positions for reverse sync
        if (data.type === 'REQUEST_STATE_CHANGE' && data.time !== undefined) {
            guestTimePositions[senderId] = {
                time: data.time,
                timestamp: Date.now()
            };
            console.log(`[SYNC] Collected time position from guest ${senderId}: ${data.time}`);
        }
        
        const commandData = { ...data, type: data.type.replace('REQUEST_', '') };
        
        // For STATE_CHANGE requests, be selective about what to honor
        if (data.type === 'REQUEST_STATE_CHANGE') {
            const hostTime = player ? player.getCurrentTime() : 0;
            const guestTime = data.time || 0;
            const timeDiff = Math.abs(hostTime - guestTime);
            const hostState = player ? player.getPlayerState() : YT.PlayerState.UNSTARTED;
            
            // Special handling for ENDED state - very restrictive
            if (data.state === YT.PlayerState.ENDED) {
                // If host is not near the end, ignore guest ENDED
                const hostDuration = player ? player.getDuration() : 0;
                if (hostDuration > 0 && hostTime < hostDuration - 5) {
                    console.log(`[HOST] Ignoring guest ENDED request - host not near end (${hostTime.toFixed(1)}s of ${hostDuration.toFixed(1)}s)`);
                    return;
                }
                
                // If host is already loading a new video, ignore ENDED from previous video
                if (loadingNewVideo) {
                    console.log(`[HOST] Ignoring guest ENDED request - host already loading new video`);
                    return;
                }
                
                // If there are videos in queue, let the host handle progression
                if (videoQueue.length > 0) {
                    console.log(`[HOST] Ignoring guest ENDED request - queue exists (${videoQueue.length} videos)`);
                    return;
                }
            }
            
            // Don't honor guest pause requests if guest is significantly ahead or behind
            if (data.state === YT.PlayerState.PAUSED) {
                if (guestTime > hostTime + 3) {
                    console.log(`[HOST] Ignoring guest PAUSED request - guest ahead (${guestTime.toFixed(1)}s vs host ${hostTime.toFixed(1)}s)`);
                    return;
                }
                // Also ignore pause from guests who are behind (likely ad-related)
                if (hostState === YT.PlayerState.PLAYING && hostTime > guestTime + 10) {
                    console.log(`[HOST] Ignoring guest PAUSED request - guest too far behind (${guestTime.toFixed(1)}s vs host ${hostTime.toFixed(1)}s)`);
                    return;
                }
            }
            
            // Don't honor guest play requests if they're too far ahead OR too far behind
            if (data.state === YT.PlayerState.PLAYING) {
                // Guest is ahead
                if (guestTime > hostTime + 5) {
                    console.log(`[HOST] Ignoring guest PLAYING request - guest too far ahead (${guestTime.toFixed(1)}s vs host ${hostTime.toFixed(1)}s)`);
                    return;
                }
                
                // Guest is behind (likely just finished an ad while host is already playing)
                // Only ignore if host is actually playing and significantly ahead
                if (hostState === YT.PlayerState.PLAYING && hostTime > guestTime + 10) {
                    console.log(`[HOST] Ignoring guest PLAYING request - guest too far behind after ad (${guestTime.toFixed(1)}s vs host ${hostTime.toFixed(1)}s)`);
                    return;
                }
            }
        }
        
        // Apply the command to host's own player first
        handleReceivedData(commandData, 'local');
        // Then broadcast to OTHER guests (exclude the sender to prevent echo)
        Object.entries(dataChannels).forEach(([id, channel]) => {
            if (id !== senderId && id !== 'host' && channel && channel.readyState === 'open') {
                channel.send(JSON.stringify(commandData));
            }
        });
        return;
    }        switch (data.type) {
            case 'KEEPALIVE':
                // Update keepalive timestamp
                lastKeepaliveReceived[senderId] = data.timestamp || Date.now();
                console.log(`[KEEPALIVE] Received from ${senderId}`);
                // Respond with our own keepalive if this is from a peer
                if (senderId !== 'local') {
                    const response = {
                        type: 'KEEPALIVE_RESPONSE',
                        timestamp: Date.now(),
                        peerId: isHost ? 'host' : currentPartyId || 'guest'
                    };
                    const channel = dataChannels[senderId];
                    if (channel && channel.readyState === 'open') {
                        try {
                            channel.send(JSON.stringify(response));
                            console.log(`[KEEPALIVE] Responded to ${senderId}`);
                        } catch (e) {
                            console.warn(`[KEEPALIVE] Failed to respond to ${senderId}:`, e.message);
                        }
                    }
                }
                return; // Don't process further
            case 'KEEPALIVE_RESPONSE':
                // Update keepalive timestamp for response
                lastKeepaliveReceived[senderId] = data.timestamp || Date.now();
                console.log(`[KEEPALIVE] Response received from ${senderId}`);
                return; // Don't process further
            case 'PING':
                // Respond to ping with pong
                if (senderId !== 'local') {
                    const pong = { type: 'PONG', timestamp: Date.now(), originalTimestamp: data.timestamp };
                    const channel = dataChannels[senderId];
                    if (channel && channel.readyState === 'open') {
                        try {
                            channel.send(JSON.stringify(pong));
                            console.log(`[PING] Ponged ${senderId}`);
                        } catch (e) {
                            console.warn(`[PING] Failed to pong ${senderId}:`, e.message);
                        }
                    }
                }
                return; // Don't process further
            case 'PONG':
                // Calculate round-trip time
                if (data.originalTimestamp) {
                    const rtt = Date.now() - data.originalTimestamp;
                    console.log(`[PONG] RTT to ${senderId}: ${rtt}ms`);
                }
                lastKeepaliveReceived[senderId] = Date.now();
                
                // Track ping responses separately for connection monitoring
                const channel = dataChannels[senderId];
                if (channel) {
                    channel._lastPingResponse = Date.now();
                }
                return; // Don't process further
            case 'HOST_INFO':
                currentHostId = data.hostId;
                break;
            case 'INITIAL_SYNC':
                // Additional safety check for player methods
                if (!player || typeof player.loadVideoById !== 'function') {
                    console.log('[SYNC] Player not ready for INITIAL_SYNC, skipping');
                    return;
                }
                
                // Check if guest currently has an ad playing
                const guestHasAd = isAdPlaying();
                if (guestHasAd) {
                    console.log('[SYNC] Guest has ad during INITIAL_SYNC, deferring sync until ad finishes');
                    // Store the sync data to apply after ad finishes
                    window.pendingInitialSync = data;
                    // Still update official duration and queue
                    officialVideoDuration = data.duration;
                    videoQueue = data.queue;
                    updateQueueUI();
                    return;
                }
                
                isSyncingFromHost = true;
                officialVideoDuration = data.duration;
                if (player.getVideoData()?.video_id !== data.videoId) {
                    window.lastVideoLoadTime = Date.now(); // Track load time for ad detection
                    player.loadVideoById(data.videoId, data.time);
                    
                    // Start ad detection timer for both hosts and guests during INITIAL_SYNC
                    startAdDetectionTimer();
                } else {
                    player.seekTo(data.time, true);
                }
                currentVideoId = data.videoId;
                hideUpNextOverlay();
                setTimeout(() => {
                    isSyncingFromHost = true;
                    if (data.state === YT.PlayerState.PLAYING) player.playVideo();
                    else if (data.state === YT.PlayerState.PAUSED) player.pauseVideo();
                }, 1000);
                videoQueue = data.queue;
                updateQueueUI();
                break;
            case 'VIDEO_DURATION':
                officialVideoDuration = data.duration;
                // Clear loading flag once we have the new video duration AND player is ready
                if (loadingNewVideo) {
                    const playerState = player ? player.getPlayerState() : YT.PlayerState.UNSTARTED;
                    if (playerState !== YT.PlayerState.UNSTARTED) {
                        console.log('[DATA] New video loaded, clearing loading flag');
                        loadingNewVideo = false;
                        processPendingMessages(); // Process any buffered sync messages
                    } else {
                        console.log('[DATA] Video duration received but player not ready yet');
                    }
                }
                
                // Chrome fix: Start watchdog timer to detect stuck buffering/unstarted state
                if (!isHost && player && data.duration > 0) {
                    // Clear any existing watchdog
                    if (window.stuckPlayerWatchdog) {
                        clearTimeout(window.stuckPlayerWatchdog);
                    }
                    
                    window.stuckPlayerWatchdog = setTimeout(() => {
                        const currentState = player.getPlayerState();
                        const currentDuration = player.getDuration();
                        
                        // If player has correct duration but is stuck in UNSTARTED or BUFFERING
                        if (currentDuration > 0 && Math.abs(currentDuration - data.duration) < 2 &&
                            (currentState === YT.PlayerState.UNSTARTED || currentState === YT.PlayerState.BUFFERING)) {
                            console.warn('[STUCK-FIX] Video loaded with correct duration but stuck in state:', YT_STATE[currentState]);
                            console.warn('[STUCK-FIX] Forcing playback to unstick player');
                            
                            // Force the video to play
                            player.playVideo();
                            
                            // If we have recent host sync data, seek to it
                            if (window.lastHostSyncTime !== undefined && window.lastHostSyncTimestamp) {
                                const timeSinceSync = (Date.now() - window.lastHostSyncTimestamp) / 1000;
                                const estimatedHostTime = window.lastHostSyncTime + timeSinceSync;
                                console.log('[STUCK-FIX] Seeking to estimated host position:', estimatedHostTime.toFixed(1));
                                player.seekTo(estimatedHostTime, true);
                            }
                        }
                    }, 5000); // Wait 5 seconds to see if it unsticks naturally
                }
                break;
            case 'NEW_VIDEO':
                // Additional safety check
                if (!player || typeof player.loadVideoById !== 'function') {
                    console.log('[DATA] Player not ready for NEW_VIDEO, skipping');
                    return;
                }
                
                // Check if this is from our own request (avoid double processing)
                const currentVideoData = player.getVideoData();
                if (currentVideoData && currentVideoData.video_id === data.videoId) {
                    console.log('[DATA] NEW_VIDEO already loaded locally, syncing state only');
                    currentVideoId = data.videoId;
                    
                    // If this is a sync message and we should auto-play, do it
                    if (data.autoPlay && player.getPlayerState() !== YT.PlayerState.PLAYING) {
                        console.log('[DATA] Auto-playing already loaded video');
                        player.playVideo();
                    }
                    return;
                }
                
                // Only load if we don't have the video loaded or it's different
                console.log('[DATA] Loading NEW_VIDEO from remote:', data.videoId);
                isSyncingFromHost = true;
                loadingNewVideo = true;
                officialVideoDuration = 0;
                currentVideoId = data.videoId;
                
                // Clear guest ready states for new video
                if (isHost) {
                    guestReadyStates = {};
                }
                window.lastVideoLoadTime = Date.now(); // Track load time for ad detection
                hideUpNextOverlay();
                updateVideoTitle();
                
                // Set timeout to reset sync flag
                setTimeout(() => {
                    isSyncingFromHost = false;
                    loadingNewVideo = false;
                }, 5000);
                
                if (isHost && data.autoPlay) {
                    intentToAutoPlay = true;
                }
                player.loadVideoById(data.videoId);
                
                // Start ad detection timer for both hosts and guests
                startAdDetectionTimer();
                break;
            case 'STATE_CHANGE': {
                // If host has an ad, guests should ignore sync
                if (data.hostHasAd && !isHost) {
                    console.log('[GUEST] Host has ad during STATE_CHANGE, ignoring sync');
                    return;
                }
                
                // Additional safety check
                if (!player || typeof player.getCurrentTime !== 'function') {
                    console.log('[DATA] Player not ready for STATE_CHANGE, skipping');
                    return;
                }
                
                // If HOST is loading a new video (from guest adding it), ignore STATE_CHANGE messages
                // The host should control its own playback state when loading guest-added videos
                if (loadingNewVideo && isHost) {
                    console.log('[HOST] Loading guest video, ignoring STATE_CHANGE from guest:', data.state);
                    return;
                }
                
                // If GUEST is loading a new video, be more lenient with sync
                if (loadingNewVideo && !isHost) {
                    console.log('[GUEST] Applying state change during video loading:', data.state);
                    lastPlayerState = data.state;
                    if (data.state === YT.PlayerState.PLAYING) {
                        player.playVideo();
                        loadingNewVideo = false; // Clear flag once playing
                        processPendingMessages(); // Process any messages that were buffered during loading
                    } else if (data.state === YT.PlayerState.PAUSED) {
                        player.pauseVideo();
                    }
                    return;
                }
                
                // Check current player state to avoid conflicts
                const currentState = player.getPlayerState();
                
                // Don't sync state changes when player is in UNSTARTED
                if (currentState === YT.PlayerState.UNSTARTED) {
                    // For guests, just log that we're waiting for host sync
                    if (!isHost) {
                        console.log('[GUEST] STATE_CHANGE received but player UNSTARTED - waiting for host sync');
                    }
                    
                    if (data.videoId && currentVideoId && data.videoId === currentVideoId) {
                        console.log('[DATA] Guest player unstarted, attempting to reload video:', data.videoId);
                        player.loadVideoById(data.videoId, data.time || 0);
                        // Don't return immediately, let the state change through after a delay
                        setTimeout(() => {
                            if (player.getPlayerState() !== YT.PlayerState.UNSTARTED) {
                                if (data.state === YT.PlayerState.PLAYING) {
                                    player.playVideo();
                                } else if (data.state === YT.PlayerState.PAUSED) {
                                    player.pauseVideo();
                                }
                            }
                        }, 1000);
                    } else {
                        console.log('[DATA] Ignoring state change - player has no video loaded');
                    }
                    return;
                }
                
                isSyncingFromHost = true;
                lastPlayerState = data.state;
                
                // Track host sync time for guest position estimation
                if (!isHost && data.time !== undefined) {
                    window.lastHostSyncTime = data.time;
                    window.lastHostSyncTimestamp = Date.now();
                }
                
                console.log('[DATA] Sync message received for state:', data.state);
                
                // Set a timeout to reset the sync flag
                setTimeout(() => {
                    isSyncingFromHost = false;
                }, 1500);
                
                if (data.state === YT.PlayerState.PLAYING) {
                    const timeDifference = Math.abs(player.getCurrentTime() - data.time);
                    if (timeDifference > 1.5) {
                        console.log(`Resyncing: Time difference of ${timeDifference.toFixed(2)}s is too large.`);
                        player.seekTo(data.time, true);
                    }
                    player.playVideo();
                } else if (data.state === YT.PlayerState.PAUSED || data.state === YT.PlayerState.ENDED) {
                    player.pauseVideo();
                }
                break;
            }
            case 'TIME_UPDATE':
                // Additional safety check
                if (!player || typeof player.getCurrentTime !== 'function') {
                    console.log('[DATA] Player not ready for TIME_UPDATE, skipping');
                    return;
                }
                if (!isHost) {
                    // If host has an ad, guests should ignore sync to avoid disruption
                    if (data.hostHasAd) {
                        console.log('[GUEST] Host has ad, ignoring sync to avoid disruption');
                        // Still track the time for estimation purposes
                        if (data.time !== undefined) {
                            window.lastHostSyncTime = data.time;
                            window.lastHostSyncTimestamp = Date.now();
                        }
                        return; // Don't sync when host has an ad
                    }
                    
                    // Track host sync time for guest position estimation
                    if (data.time !== undefined) {
                        window.lastHostSyncTime = data.time;
                        window.lastHostSyncTimestamp = Date.now();
                    }
                    
                    // Check if we're syncing to the same video
                    const currentVideoData = player.getVideoData();
                    const currentVideoId = currentVideoData ? currentVideoData.video_id : null;
                    
                    // If we're loading a new video, ignore time updates for different videos
                    if (loadingNewVideo && currentVideoId && currentVideoId !== data.videoId) {
                        console.log('[DATA] Ignoring TIME_UPDATE for different video during loading');
                        return;
                    }
                    
                    const localTime = player.getCurrentTime();
                    const localState = player.getPlayerState();
                    const timeDifference = Math.abs(localTime - data.time);
                    
                    // Chrome fix: Force play if stuck in BUFFERING with correct duration
                    if (data.state === YT.PlayerState.PLAYING && localState === YT.PlayerState.BUFFERING) {
                        const currentDuration = player.getDuration();
                        // If we have correct duration and host is playing, force play
                        if (currentDuration > 0 && Math.abs(currentDuration - officialVideoDuration) < 2) {
                            console.warn('[STUCK-FIX] Player stuck buffering with correct duration, forcing play');
                            player.seekTo(data.time, true);
                            player.playVideo();
                            break;
                        }
                    }
                    
                    if (data.state === YT.PlayerState.PLAYING && (localState !== YT.PlayerState.PLAYING || timeDifference > 3.5)) {
                        const currentDuration = player.getDuration();
                        if (officialVideoDuration > 0 && Math.abs(currentDuration - officialVideoDuration) > 2) {
                            console.log('[DATA] Duration mismatch, ignoring sync');
                            break;
                        }
                        
                        // Only sync if we're not in UNSTARTED state, unless we're actively loading
                        if (localState === YT.PlayerState.UNSTARTED) {
                            const currentDuration = player.getDuration();
                            
                            // Chrome fix: If video is loaded (has duration) but stuck in UNSTARTED, force it
                            if (currentDuration > 0 && Math.abs(currentDuration - officialVideoDuration) < 2) {
                                console.warn('[STUCK-FIX] Video loaded but stuck in UNSTARTED, forcing play');
                                player.seekTo(data.time, true);
                                player.playVideo();
                                break;
                            }
                            
                            // For guests, just wait for natural sync resolution
                            if (!isHost) {
                                console.log('[GUEST] UNSTARTED state during sync - waiting for natural resolution');
                            }
                            
                            // If we're loading a new video, try to load it first
                            if (data.videoId && currentVideoId && data.videoId === currentVideoId) {
                                console.log('[DATA] Retrying video load for sync - player in UNSTARTED state');
                                player.loadVideoById(data.videoId, data.time);
                                // Give it a moment to load, then try sync again
                                setTimeout(() => {
                                    if (player.getPlayerState() !== YT.PlayerState.UNSTARTED) {
                                        player.seekTo(data.time, true);
                                        player.playVideo();
                                    } else {
                                        // Still stuck, try forcing it
                                        console.warn('[STUCK-FIX] Still stuck after retry, forcing play');
                                        player.playVideo();
                                    }
                                }, 1000);
                            } else {
                                console.log('[DATA] Cannot sync - no video loaded locally');
                            }
                            break;
                        }
                        
                        isSyncingFromHost = true;
                        player.seekTo(data.time, true);
                        player.playVideo();
                    } 
                    else if (data.state === YT.PlayerState.PAUSED && localState !== YT.PlayerState.PAUSED && localState !== YT.PlayerState.UNSTARTED) {
                        console.log("Heartbeat correcting to PAUSED state.");
                        isSyncingFromHost = true;
                        player.pauseVideo();
                    }
                    
                    // Guest ad detection after time sync (but don't try to skip)
                    if (data.duration && data.duration > 0) {
                        // Check if guest has different duration than expected
                        const adPlaying = isAdPlaying();
                        if (adPlaying) {
                            console.log(`[GUEST-AD] Ad detected after time sync, guest will wait`);
                            // Guest just waits for host to get through the ad
                        }
                    }
                }
                break;
            case 'REQUEST_POSITION':
                // Guest responds with current position
                if (!isHost && player && typeof player.getCurrentTime === 'function') {
                    const currentTime = player.getCurrentTime();
                    const currentState = player.getPlayerState();
                    console.log(`[REVERSE-SYNC] Responding with position: ${currentTime}`);
                    
                    const responseData = { 
                        type: 'POSITION_RESPONSE', 
                        time: currentTime, 
                        state: currentState 
                    };
                    
                    const hostChannel = dataChannels['host'];
                    if (hostChannel && hostChannel.readyState === 'open') {
                        hostChannel.send(JSON.stringify(responseData));
                    }
                }
                break;
            case 'POSITION_RESPONSE':
                // Host collects guest positions for reverse sync
                if (isHost) {
                    guestTimePositions[senderId] = {
                        time: data.time,
                        timestamp: Date.now()
                    };
                    console.log(`[REVERSE-SYNC] Received position from guest ${senderId}: ${data.time}`);
                }
                break;
            case 'GUEST_READY':
                // Guest notifies host that video is loaded with correct duration
                if (isHost) {
                    guestReadyStates[senderId] = {
                        duration: data.duration,
                        videoId: data.videoId,
                        hasAd: data.hasAd || false,
                        timestamp: Date.now()
                    };
                    console.log(`[GUEST-READY] Guest ${senderId} ready with duration: ${data.duration}s, hasAd: ${data.hasAd}`);
                    // Check if all guests are ready and auto-start
                    checkAllGuestsReadyAndAutoStart();
                }
                break;
            case 'ADD_TO_QUEUE':
                if (isHost) {
                    videoQueue.push(data.video);
                    // Broadcast queue update to all guests
                    const queueUpdateData = { type: 'QUEUE_UPDATE', queue: videoQueue };
                    Object.entries(dataChannels).forEach(([id, channel]) => {
                        if (id !== 'host' && channel && channel.readyState === 'open') {
                            channel.send(JSON.stringify(queueUpdateData));
                        }
                    });
                    updateQueueUI(); // Update host's own queue UI
                }
                break;
            case 'PLAY_FROM_QUEUE':
                if (isHost && videoQueue[data.index]) {
                    const videoToPlay = videoQueue.splice(data.index, 1)[0];
                    const newVideoData = { type: 'NEW_VIDEO', videoId: videoToPlay.videoId, autoPlay: true };
                    const queueUpdateData = { type: 'QUEUE_UPDATE', queue: videoQueue };
                    
                    // Apply to host first
                    handleReceivedData(newVideoData, 'local');
                    handleReceivedData(queueUpdateData, 'local');
                    
                    // Then broadcast to guests
                    Object.entries(dataChannels).forEach(([id, channel]) => {
                        if (id !== 'host' && channel && channel.readyState === 'open') {
                            channel.send(JSON.stringify(newVideoData));
                            channel.send(JSON.stringify(queueUpdateData));
                        }
                    });
                }
                break;
            case 'REMOVE_FROM_QUEUE':
                if (isHost && data.index >= 0 && data.index < videoQueue.length) {
                    videoQueue.splice(data.index, 1);
                    const queueUpdateData = { type: 'QUEUE_UPDATE', queue: videoQueue };
                    Object.entries(dataChannels).forEach(([id, channel]) => {
                        if (id !== 'host' && channel && channel.readyState === 'open') {
                            channel.send(JSON.stringify(queueUpdateData));
                        }
                    });
                    updateQueueUI(); // Update host's own queue UI
                } else if (isHost) {
                    console.warn('[QUEUE] Invalid index for REMOVE_FROM_QUEUE:', data.index);
                }
                break;
            case 'USER_LEAVING':
                console.log('[DATA] User leaving:', senderId);
                
                // Clean up connections and user list
                if (peerConnections[senderId]) {
                    peerConnections[senderId].close();
                    delete peerConnections[senderId];
                }
                
                if (dataChannels[senderId]) {
                    dataChannels[senderId].close();
                    delete dataChannels[senderId];
                }
                
                // Remove user from local user list
                delete localUserList[senderId];
                
                // If we're the host, broadcast updated user list to everyone
                if (isHost) {
                    const users = { [myAuthId]: { name: myName } };
                    Object.entries(peerConnections).forEach(([id, pc]) => {
                        if (pc.peerName) users[id] = { name: pc.peerName };
                    });
                    broadcastData({ type: 'USER_LIST', users });
                    
                    // Also clean up Firestore guest document
                    if (partyDocRef) {
                        partyDocRef.collection('guests').doc(senderId).delete().catch(error => 
                            console.error("Error removing guest document:", error)
                        );
                    }
                }
                
                // Update local UI
                updateUserList(localUserList);
                updateConnectionStatus();
                break;
            case 'QUEUE_UPDATE':
                videoQueue = data.queue;
                updateQueueUI();
                break;
            case 'USER_LIST':
                updateUserList(data.users);
                break;
        }
    }

    // Copy invite link handler
    copyInviteBtn.addEventListener('click', async () => {
        const link = inviteLinkInput.value;
        if (!link) return;
        
        try {
            // Modern clipboard API (works in HTTPS contexts)
            await navigator.clipboard.writeText(link);
            copyInviteBtn.textContent = 'Copied!';
            setTimeout(() => (copyInviteBtn.textContent = 'Copy'), 1500);
        } catch (err) {
            console.warn('Modern clipboard failed, trying fallback:', err);
            // Fallback for older browsers or non-HTTPS contexts
            try {
                // Focus the input first
                inviteLinkInput.focus();
                // Select all text
                inviteLinkInput.select();
                // For mobile browsers, ensure full selection
                inviteLinkInput.setSelectionRange(0, inviteLinkInput.value.length);
                
                // Copy the selection
                const success = document.execCommand('copy');
                
                copyInviteBtn.textContent = success ? 'Copied!' : 'Copy failed';
                setTimeout(() => (copyInviteBtn.textContent = 'Copy'), 1500);
                
                // Clear selection
                if (window.getSelection) {
                    window.getSelection().removeAllRanges();
                }
                // Blur the input to remove focus
                inviteLinkInput.blur();
                
            } catch (fallbackErr) {
                console.error('Fallback copy also failed:', fallbackErr);
                copyInviteBtn.textContent = 'Copy failed';
                setTimeout(() => (copyInviteBtn.textContent = 'Copy'), 1500);
            }
        }
    });

    function startHostHeartbeat() {
        if (hostHeartbeatInterval) clearInterval(hostHeartbeatInterval);
        hostHeartbeatInterval = setInterval(() => {
            if (isHost && player && typeof player.getCurrentTime === 'function') {
                const currentState = player.getPlayerState();
                const hostTime = player.getCurrentTime();
                
                // Check for reverse sync scenario (host behind guests due to ad/buffer)
                if (currentState === YT.PlayerState.PLAYING && Object.keys(guestTimePositions).length > 0) {
                    const now = Date.now();
                    const recentGuestPositions = [];
                    
                    // Collect recent guest positions (within last 5 seconds)
                    Object.entries(guestTimePositions).forEach(([guestId, posData]) => {
                        if (now - posData.timestamp < 5000) {
                            recentGuestPositions.push(posData.time);
                        }
                    });
                    
                    if (recentGuestPositions.length > 0) {
                        const avgGuestTime = recentGuestPositions.reduce((sum, time) => sum + time, 0) / recentGuestPositions.length;
                        const timeDifference = avgGuestTime - hostTime;
                        
                        // If host is significantly behind guests (10+ seconds), sync host to guests
                        if (timeDifference > 10) {
                            console.log(`[REVERSE-SYNC] Host behind by ${timeDifference.toFixed(2)}s, seeking forward to match guests`);
                            player.seekTo(avgGuestTime, true);
                            
                            // Clear guest positions after sync
                            guestTimePositions = {};
                            
                            // Don't send normal time update this cycle
                            return;
                        }
                    }
                }
                
                // Check if host is playing an ad
                const hostHasAd = isAdPlaying();
                
                const data = { 
                    type: 'TIME_UPDATE', 
                    time: hostTime, 
                    state: currentState,
                    hostHasAd: hostHasAd // Include ad status
                };
                
                // Log when host has an ad
                if (hostHasAd) {
                    console.log('[HOST-AD] Host has ad, notifying guests to ignore sync');
                }
                
                Object.entries(dataChannels).forEach(([id, channel]) => {
                    if (id !== 'host' && channel && channel.readyState === 'open') {
                        channel.send(JSON.stringify(data));
                    }
                });
                
                // Update host activity timestamp in Firestore for backup detection
                // Do this less frequently to avoid excessive writes
                if (!this._lastFirestoreUpdate || (Date.now() - this._lastFirestoreUpdate) > 30000) {
                    this._lastFirestoreUpdate = Date.now();
                    partyDocRef.update({
                        lastHeartbeat: firebase.firestore.FieldValue.serverTimestamp()
                    }).catch(err => {
                        // If permissions fail, fall back to WebRTC-only detection
                        console.warn('[HEARTBEAT] Failed to update Firestore timestamp (using WebRTC-only detection):', err.message);
                    });
                }
            }
        }, 3000); // Reduced frequency from 1.5s to 3s for better stability
        
        // Start connection monitoring and keepalive
        startConnectionKeepalive();
        startConnectionMonitor();
    }

    function startConnectionKeepalive() {
        if (connectionKeepaliveInterval) clearInterval(connectionKeepaliveInterval);
        
        connectionKeepaliveInterval = setInterval(() => {
            const keepaliveData = { 
                type: 'KEEPALIVE', 
                timestamp: Date.now(),
                peerId: isHost ? 'host' : currentPartyId || 'guest'
            };
            
            // Send keepalive to all connected peers
            Object.entries(dataChannels).forEach(([id, channel]) => {
                if (channel && channel.readyState === 'open') {
                    // Check buffer size to avoid overwhelming the connection
                    if (channel.bufferedAmount > 8192) { // 8KB threshold
                        console.warn(`[KEEPALIVE] Skipping ${id} due to high buffer: ${channel.bufferedAmount} bytes`);
                        return;
                    }
                    
                    try {
                        channel.send(JSON.stringify(keepaliveData));
                        console.log(`[KEEPALIVE] Sent to ${id} (buffer: ${channel.bufferedAmount})`);
                    } catch (e) {
                        console.warn(`[KEEPALIVE] Failed to send to ${id}:`, e.message);
                    }
                }
            });
        }, CONNECTION_KEEPALIVE_INTERVAL);
    }

    function startConnectionMonitor() {
        if (connectionMonitorInterval) clearInterval(connectionMonitorInterval);
        
        connectionMonitorInterval = setInterval(() => {
            const now = Date.now();
            
            // Check each peer connection's health
            Object.entries(peerConnections).forEach(([peerId, pc]) => {
                if (!pc) return;
                
                const channel = dataChannels[peerId];
                const iceState = pc.iceConnectionState;
                const connState = pc.connectionState;
                
                // Log connection issues (throttled)
                if ((iceState === 'disconnected' || iceState === 'failed' || connState === 'disconnected' || connState === 'failed') &&
                    (!pc._lastIssueLog || (now - pc._lastIssueLog) > 30000)) {
                    console.warn(`[CONN-MONITOR] ${peerId}: ICE=${iceState}, Conn=${connState}, Channel=${channel?.readyState || 'none'}`);
                    pc._lastIssueLog = now;
                }
                
                // Check for stale keepalives (only for active connections)
                if (iceState === 'connected' || iceState === 'completed') {
                    const lastKeepalive = lastKeepaliveReceived[peerId];
                    const lastPingResponse = channel?._lastPingResponse || 0;
                    
                    // Only worry about keepalives if we haven't had ANY response (keepalive OR ping) recently
                    const lastAnyResponse = Math.max(lastKeepalive || 0, lastPingResponse);
                    
                    if (lastAnyResponse > 0 && (now - lastAnyResponse) > CONNECTION_KEEPALIVE_INTERVAL * 6) { // Very conservative: 6x interval
                        console.warn(`[CONN-MONITOR] ${peerId}: No response (keepalive OR ping) for ${Math.floor((now - lastAnyResponse) / 1000)}s`);
                        
                        // Only try to ping if we haven't pinged very recently
                        if (channel && channel.readyState === 'open' && 
                            channel.bufferedAmount < 4096 && 
                            (!channel._lastPingTime || (now - channel._lastPingTime) > 90000)) { // Very conservative: 90s between pings
                            
                            try {
                                channel.send(JSON.stringify({ type: 'PING', timestamp: now }));
                                channel._lastPingTime = now;
                                console.log(`[CONN-MONITOR] Sent connection test ping to ${peerId}`);
                            } catch (e) {
                                console.warn(`[CONN-MONITOR] Failed to ping ${peerId}:`, e.message);
                            }
                        }
                    }
                }
            });
            
            // Clean up old keepalive records
            Object.keys(lastKeepaliveReceived).forEach(peerId => {
                if (!peerConnections[peerId] || (now - lastKeepaliveReceived[peerId]) > 300000) {
                    delete lastKeepaliveReceived[peerId];
                }
            });
            
        }, CONNECTION_MONITOR_INTERVAL);
    }
    
    // Backup host disconnection detection via Firestore monitoring
    function startHostActivityMonitoring() {
        if (isHost) return; // Only guests monitor host activity
        
        let hostActivityInterval;
        let lastHostActivity = Date.now();
        
        // Monitor party document for host activity timestamps
        const hostActivityListener = partyDocRef.onSnapshot((doc) => {
            if (doc.exists) {
                const data = doc.data();
                const lastHeartbeat = data.lastHeartbeat;
                
                if (lastHeartbeat) {
                    lastHostActivity = lastHeartbeat.toMillis ? lastHeartbeat.toMillis() : lastHeartbeat;
                }
            }
        });
        
        // Check host activity every 10 seconds
        hostActivityInterval = setInterval(() => {
            if (isHost || hostMigrationInProgress) return; // Skip if we became host or migration in progress
            
            const now = Date.now();
            const timeSinceLastActivity = now - lastHostActivity;
            
            // If no host activity for 45 seconds, trigger migration
            if (timeSinceLastActivity > 45000) {
                console.warn(`[HOST-MONITOR] No host activity for ${Math.floor(timeSinceLastActivity / 1000)}s, triggering migration`);
                
                // Clean up monitoring
                clearInterval(hostActivityInterval);
                hostActivityListener();
                
                // Start migration if not already in progress
                if (!hostMigrationInProgress) {
                    handleHostDisconnection();
                }
            }
        }, 10000);
        
        // Store cleanup function globally for later use
        window._hostActivityCleanup = () => {
            if (hostActivityInterval) clearInterval(hostActivityInterval);
            hostActivityListener();
        };
    }

    async function handleHostDisconnection() {
        if (hostMigrationInProgress) {
            console.log('[MIGRATION] Already in progress, ignoring duplicate call');
            return;
        }
        
        hostMigrationInProgress = true;
        console.log('[MIGRATION] Host disconnected, starting election process...');
        
        // Set a safety timeout to reset migration flag if it gets stuck
        const migrationTimeout = setTimeout(() => {
            console.warn('[MIGRATION] Migration timeout - resetting flag');
            hostMigrationInProgress = false;
        }, 15000);
        
        // Update UI immediately
        connectionStatus.textContent = 'Status: Host disconnected, electing new host...';
        connectionStatus.className = 'status connecting';
        
        try {
            // Step 1: Clean up all existing connections
            await cleanupAllConnections();
            
            // Step 2: Determine if we should become host
            const shouldBecomeHost = await determineNewHost();
            
            if (shouldBecomeHost) {
                console.log('[MIGRATION] This client will become the new host');
                await becomeNewHost();
            } else {
                console.log('[MIGRATION] Waiting for another client to become host');
                await waitForNewHost();
            }
            
            clearTimeout(migrationTimeout);
            
        } catch (error) {
            console.error('[MIGRATION] Host migration failed:', error);
            clearTimeout(migrationTimeout);
            hostMigrationInProgress = false;
            
            // Fallback: refresh the page
            alert('Host migration failed. The page will refresh to reconnect.');
            window.location.reload();
        }
    }

    // Step 1: Clean up all existing connections
    async function cleanupAllConnections() {
        console.log('[MIGRATION] Cleaning up existing connections');
        
        // Close all peer connections
        for (const [peerId, pc] of Object.entries(peerConnections)) {
            try {
                pc.close();
            } catch (e) {
                console.warn('[MIGRATION] Error closing connection:', peerId, e);
            }
            delete peerConnections[peerId];
        }
        
        // Close all data channels
        for (const [peerId, channel] of Object.entries(dataChannels)) {
            try {
                if (channel.readyState === 'open') {
                    channel.close();
                }
            } catch (e) {
                console.warn('[MIGRATION] Error closing channel:', peerId, e);
            }
            delete dataChannels[peerId];
        }
        
        // Clear intervals
        if (hostHeartbeatInterval) {
            clearInterval(hostHeartbeatInterval);
            hostHeartbeatInterval = null;
        }
        if (connectionKeepaliveInterval) {
            clearInterval(connectionKeepaliveInterval);
            connectionKeepaliveInterval = null;
        }
        if (connectionMonitorInterval) {
            clearInterval(connectionMonitorInterval);
            connectionMonitorInterval = null;
        }
        
        // Clear host activity monitoring
        if (window._hostActivityCleanup) {
            window._hostActivityCleanup();
            delete window._hostActivityCleanup;
        }
        
        // Clear keepalive tracking
        lastKeepaliveReceived = {};
        
        // Reset connection state
        isHost = false;
        currentHostId = '';
        
        // Clear user list except for ourselves
        localUserList = { [myAuthId]: { name: myName } };
        updateUserList(localUserList);
        
        console.log('[MIGRATION] Cleanup complete - preserved our own user info');
    }

    // Step 2: Determine who should become the new host
    async function determineNewHost() {
        try {
            console.log('[MIGRATION] Determining new host from Firestore guest list...');
            
            // Get all connected guests from Firestore (more reliable than local list)
            const guestsSnapshot = await partyDocRef.collection('guests').get();
            const allUsers = {};
            
            // Include ourselves
            allUsers[myAuthId] = { name: myName };
            
            // Add all guests from Firestore
            guestsSnapshot.forEach(doc => {
                if (doc.exists) {
                    const data = doc.data();
                    allUsers[doc.id] = { name: data.name || 'Unknown' };
                }
            });
            
            // Sort user IDs deterministically (alphabetical order)
            const sortedUserIds = Object.keys(allUsers).sort();
            
            console.log('[MIGRATION] All users for election:', sortedUserIds);
            console.log('[MIGRATION] My ID:', myAuthId);
            
            // The first user in sorted order becomes host
            const newHostId = sortedUserIds[0];
            
            console.log('[MIGRATION] Elected host ID:', newHostId);
            return newHostId === myAuthId;
            
        } catch (error) {
            console.error('[MIGRATION] Error determining new host:', error);
            // Fallback: use timestamp-based election to avoid conflicts
            const electionTimestamp = Date.now();
            console.log('[MIGRATION] Using timestamp-based fallback:', electionTimestamp);
            
            // Wait a random delay based on our user ID to avoid simultaneous attempts
            const delay = Math.abs(myAuthId.split('').reduce((a, b) => a + b.charCodeAt(0), 0)) % 5000;
            console.log('[MIGRATION] Waiting', delay, 'ms before attempting to claim host role');
            await new Promise(resolve => setTimeout(resolve, delay));
            
            return true; // Try to become host after delay
        }
    }

    // Step 3A: Become the new host
    async function becomeNewHost() {
        try {
            console.log('[MIGRATION] Attempting to claim host role...');
            
            // Use a transaction to safely claim host role
            const success = await db.runTransaction(async (transaction) => {
                const partyDoc = await transaction.get(partyDocRef);
                
                if (!partyDoc.exists) {
                    throw new Error('Party document no longer exists');
                }
                
                const currentData = partyDoc.data();
                const currentHostId = currentData.hostId;
                const currentMigratedAt = currentData.migratedAt;
                
                // If there's already a new host (someone else claimed it), abort
                if (currentHostId !== myAuthId && currentMigratedAt && 
                    (Date.now() - currentMigratedAt.toMillis()) < 30000) { // Within last 30 seconds
                    console.log('[MIGRATION] Another user already claimed host role:', currentHostId);
                    return false; // Signal that someone else became host
                }
                
                // Only proceed if current host is different or very old migration
                if (currentHostId === myAuthId) {
                    console.log('[MIGRATION] Already the host, skipping');
                    return true; // We're already host
                }
                
                // Claim host role
                transaction.update(partyDocRef, {
                    hostId: myAuthId,
                    migratedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    previousHostId: currentHostId
                });
                
                console.log('[MIGRATION] Host role claimed in Firestore');
                return true; // Successfully claimed host role
            });
            
            if (!success) {
                // Someone else became host, we should wait for them
                console.log('[MIGRATION] Host role already claimed by another user, switching to wait mode');
                await waitForNewHost();
                return;
            }
            
            // Clean up old guest documents
            await cleanupOldGuestDocuments();
            
            // Update local state
            isHost = true;
            currentHostId = myAuthId;
            
            // Update UI
            updateUIForNewHost();
            updateSkipButtonState(); // Update button states for new host
            
            // Start host functionality
            listenForGuests();
            startHostHeartbeat();
            
            // Broadcast to any remaining connections
            broadcastData({ 
                type: 'HOST_INFO', 
                hostId: myAuthId 
            });
            
            broadcastData({ 
                type: 'USER_LIST', 
                users: localUserList 
            });
            
            console.log('[MIGRATION] Successfully became new host');
            hostMigrationInProgress = false;
            updateConnectionStatus();
            
        } catch (error) {
            console.error('[MIGRATION] Failed to become host:', error);
            throw error;
        }
    }

    // Step 3B: Wait for another client to become host
    async function waitForNewHost() {
        return new Promise((resolve, reject) => {
            console.log('[MIGRATION] Waiting for new host...');
            
            // Set a timeout in case no one becomes host
            const timeout = setTimeout(() => {
                console.warn('[MIGRATION] Timeout waiting for new host');
                unsubscribe();
                reject(new Error('Timeout waiting for new host'));
            }, 10000); // 10 second timeout
            
            // Listen for host changes
            const unsubscribe = partyDocRef.onSnapshot(
                (doc) => {
                    if (!doc.exists) {
                        console.error('[MIGRATION] Party document deleted');
                        clearTimeout(timeout);
                        unsubscribe();
                        reject(new Error('Party document deleted'));
                        return;
                    }
                    
                    const data = doc.data();
                    const newHostId = data.hostId;
                    
                    // Check if we have a new host (and it's not us)
                    if (newHostId && newHostId !== myAuthId && newHostId !== currentHostId) {
                        console.log('[MIGRATION] New host detected:', newHostId);
                        
                        clearTimeout(timeout);
                        unsubscribe();
                        
                        // Update local state
                        currentHostId = newHostId;
                        
                        // Reconnect as guest
                        reconnectAsGuest()
                            .then(() => {
                                hostMigrationInProgress = false;
                                resolve();
                            })
                            .catch(reject);
                    }
                },
                (error) => {
                    console.error('[MIGRATION] Error listening for new host:', error);
                    clearTimeout(timeout);
                    unsubscribe();
                    reject(error);
                }
            );
        });
    }

    // Reconnect to new host as guest
    async function reconnectAsGuest() {
        try {
            console.log('[MIGRATION] Reconnecting as guest to new host');
            
            // Small delay to let new host initialize
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Join as guest
            await joinParty();
            
            console.log('[MIGRATION] Successfully reconnected as guest');
            updateConnectionStatus();
            
        } catch (error) {
            console.error('[MIGRATION] Failed to reconnect as guest:', error);
            throw error;
        }
    }

    // Helper: Clean up old guest documents
    async function cleanupOldGuestDocuments() {
        try {
            console.log('[MIGRATION] Cleaning up old guest documents');
            
            const guestsSnapshot = await partyDocRef.collection('guests').get();
            
            if (!guestsSnapshot.empty) {
                const batch = db.batch();
                guestsSnapshot.docs.forEach(doc => {
                    batch.delete(doc.ref);
                });
                await batch.commit();
                console.log('[MIGRATION] Cleared old guest documents');
            }
            
        } catch (error) {
            console.warn('[MIGRATION] Error cleaning guest documents:', error);
            // Non-fatal error
        }
    }

    // Update the existing updateUIForNewHost function
    function updateUIForNewHost() {
        // Show create invite button again
        createInviteBtn.classList.remove('hidden');
        createInviteBtn.disabled = false;
        createInviteBtn.textContent = 'Create Invite Link';
        
        // Hide existing invite link
        inviteRow.classList.add('hidden');
        inviteLinkInput.value = '';
        
        // Update user list
        updateUserList(localUserList);
        
        console.log('[MIGRATION] UI updated for new host');
    }

    function updateVideoTitle() {
        if (player && typeof player.getVideoData === 'function') {
            const title = player.getVideoData().title;
            if (title) {
                videoTitleElement.textContent = title;
                videoTitleElement.title = title;
            }
        }
    }

    // Skip to next video function
    function skipToNextVideo() {
        if (videoQueue.length === 0) {
            console.log('[SKIP] No videos in queue to skip to');
            return;
        }
        
        console.log('[SKIP] Manually skipping to next video in queue');
        handleUserAction({ type: 'PLAY_FROM_QUEUE', index: 0 });
    }
    
    // Update skip button state based on queue
    function updateSkipButtonState() {
        skipVideoBtn.disabled = videoQueue.length === 0;
        // Update shuffle button - only enabled for host with items in queue
        shuffleQueueBtn.disabled = !isHost || videoQueue.length === 0;
        shuffleQueueBtn.style.display = isHost ? 'block' : 'none';
    }

    function updateQueueUI() {
        queueList.innerHTML = '';
        if (videoQueue.length === 0) {
            queueList.innerHTML = '<li>Queue is empty.</li>';
            return;
        }
        videoQueue.forEach((video, index) => {
            const li = document.createElement('li');
            li.title = "Click to Play Now";
            const durationHTML = video.duration ? `<div class="video-duration">${video.duration}</div>` : '';
            li.innerHTML = `<img src="${video.thumbnailUrl}" alt="${video.title}"><div class="video-info"><div><div class="video-title">${video.title}</div>${durationHTML}</div><button class="remove-btn" title="Remove from queue" data-index="${index}">Remove</button></div>`;
            li.addEventListener('click', (e) => {
                if (e.target.classList.contains('remove-btn')) return;
                handleUserAction({ type: 'PLAY_FROM_QUEUE', index });
            });
            li.querySelector('.remove-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                handleUserAction({ type: 'REMOVE_FROM_QUEUE', index });
            });
            queueList.appendChild(li);
        });
        
        // Update skip button state
        updateSkipButtonState();
    }

    function updateConnectionStatus() {
        const states = Object.values(peerConnections).map(pc => pc.connectionState);
        let statusText = 'Disconnected';
        let statusClass = 'disconnected';
        const connectedCount = states.filter(s => s === 'connected').length;
        if (isHost && states.length === 0) {
            statusText = 'Waiting for guests...';
            statusClass = 'connecting';
        } else if (connectedCount > 0 || (!isHost && peerConnections['host'] && peerConnections['host'].connectionState === 'connected')) {
            statusText = 'Connected';
            statusClass = 'connected';
        } else if (!isHost && states.some(s => ['connecting', 'new', 'checking'].includes(s))) {
            statusText = 'Connecting...';
            statusClass = 'connecting';
        }
        // Show just "Connected" when connected; otherwise keep the "Status: ..." prefix
        connectionStatus.textContent = statusClass === 'connected' ? 'Connected' : `Status: ${statusText}`;
        connectionStatus.className = `status ${statusClass}`;
    }

    function updateUserList(users = {}) {
        localUserList = users;
        userList.innerHTML = '';
        const uniqueUsers = {};
        Object.values(users).forEach(user => {
            if (user.name && !uniqueUsers[user.name]) {
                uniqueUsers[user.name] = user;
            }
        });
        if (!uniqueUsers[myName]) {
            uniqueUsers[myName] = { name: myName };
        }
        Object.values(uniqueUsers).forEach(user => {
            const li = document.createElement('li');
            let suffix = '';
            if (user.name === myName) {
                suffix = isHost ? ' (Host, You)' : ' (You)';
            }
            li.textContent = user.name + suffix;
            userList.appendChild(li);
        });
    }
</script>

</body>
</html>