<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube Sync with Firebase</title>
    <style>
        :root {
            --yt-red: #FF0000;
            --yt-red-hover: #c00;
            --yt-dark: #212121;
            --yt-light-dark: #333;
            --primary-background: #f9f9f9;
            --secondary-background: #ffffff;
            --primary-text: #030303;
            --secondary-text: #606060;
            --border-color: #e0e0e0;
            --hover-background: #f2f2f2;
            --input-background: #ffffff;
            --header-background: var(--yt-dark);
            --header-text: #ffffff;
            --search-button-bg: #f8f8f8;
            --search-input-bg: #fff;
            --search-input-border: #ccc;
            --search-input-focus-border: #1c62b9;
        }
        body.dark {
            --primary-background: #0f0f0f;
            --secondary-background: #212121;
            --primary-text: #f1f1f1;
            --secondary-text: #aaaaaa;
            --border-color: #3d3d3d;
            --hover-background: #3d3d3d;
            --input-background: #121212;
            --header-background: #212121;
            --header-text: #ffffff;
            --search-button-bg: #3d3d3d;
            --search-input-bg: #121212;
            --search-input-border: #303030;
            --search-input-focus-border: var(--yt-red);
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Roboto', 'Arial', sans-serif;
            margin: 0;
            background-color: var(--primary-background);
            color: var(--primary-text);
            transition: background-color 0.2s, color 0.2s;
        }
        .header { display: flex; align-items: center; justify-content: space-between; padding: 0 16px 0 24px; height: 56px; background-color: var(--header-background); color: var(--header-text); }
        .logo-container { display: flex; align-items: center; gap: 8px; }
        .logo-container h1 { font-size: 20px; margin: 0; font-weight: 500; }
        .search-container-header { flex: 0 1 728px; display: flex; }
        #searchInput { width: 100%; padding: 10px 12px; font-size: 16px; border-radius: 40px 0 0 40px; border: 1px solid var(--search-input-border); background-color: var(--search-input-bg); color: var(--primary-text); }
        #searchInput:focus { border-color: var(--search-input-focus-border); outline: none; }
        #searchButton { padding: 0 24px; border-radius: 0 40px 40px 0; border: 1px solid var(--search-input-border); border-left: none; cursor: pointer; background-color: var(--hover-background); }
        #searchButton svg { fill: var(--primary-text); }
        .user-actions { display: flex; align-items: center; margin-left: 16px; }
        #darkModeToggle { background: none; border: none; cursor: pointer; padding: 8px; border-radius: 50%; display: flex; align-items: center; justify-content: center; }
        #darkModeToggle:hover { background-color: var(--yt-light-dark); }
        #darkModeToggle svg { fill: var(--header-text); }
        .moon-icon { display: none; }
        body.dark .sun-icon { display: none; }
        body.dark .moon-icon { display: block; }
        .page-container { display: flex; flex-direction: column; padding: 24px; max-width: 1440px; margin: 0 auto; }
        @media (min-width: 1024px) {
            .page-container { display: grid; grid-template-columns: 1fr 402px; gap: 24px; align-items: flex-start; }
            .chat-container { grid-column: 1 / 2; grid-row: 2 / 3; margin-top: 0; } /* rely on grid row gap */
        }
        .main-content { flex: 1; min-width: 0; }
        @media (min-width: 1024px) { .main-content { grid-column: 1 / 2; grid-row: 1 / 2; } }
        .sidebar { width: 100%; max-width: 402px; margin: 24px auto 0 auto; }
        @media (min-width: 1024px) { .sidebar { grid-column: 2 / 3; grid-row: 1 / 3; width: 402px; margin: 0; flex-shrink: 0; } }
        .sidebar-section { background-color: var(--secondary-background); border: 1px solid var(--border-color); border-radius: 12px; padding: 16px; margin-bottom: 16px; }
        .sidebar-section h2, .sidebar-section h3 { margin-top: 0; border-bottom: 1px solid var(--border-color); padding-bottom: 8px; margin-bottom: 12px; color: var(--primary-text); }
        .player-container { width: 100%; aspect-ratio: 16 / 9; background-color: #000; border-radius: 12px; overflow: hidden; position: relative; }
        #player { width: 100%; height: 100%; }
        #results, #queueList { list-style: none; padding: 0; max-height: 300px; overflow-y: auto; }
        #results li, #queueList li { display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 8px; border-radius: 4px; }
        #results li:hover, #queueList li:hover { background-color: var(--hover-background); }
        #results img, #queueList img { width: 120px; height: 67px; object-fit: cover; border-radius: 4px; flex-shrink: 0; }
        .video-info { flex-grow: 1; display: flex; justify-content: space-between; align-items: center; gap: 8px; min-width: 0; }
        .video-title { font-weight: 500; color: var(--primary-text); white-space: normal; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; }
        .queue-btn, .remove-btn { padding: 6px 12px; font-size: 12px; flex-shrink: 0; background-color: var(--hover-background); color: var(--primary-text); border: 1px solid var(--border-color); border-radius: 18px; cursor: pointer; }
        body.dark .queue-btn, body.dark .remove-btn { background-color: var(--yt-light-dark); }
        .user-modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.7); display: flex; align-items: center; justify-content: center; z-index: 1000; }
        .user-container { background: var(--secondary-background); color: var(--primary-text); padding: 24px; border-radius: 12px; text-align: center; }
        .user-container input { background-color: var(--input-background); color: var(--primary-text); border: 1px solid var(--border-color); border-radius: 8px; padding: 8px; margin: 0 8px; }
        #inviteLink { 
            font-size: 14px; 
            background-color: var(--input-background); 
            color: var(--primary-text); 
            border: 1px solid var(--border-color); 
            padding: 8px; 
            border-radius: 8px; 
            width: calc(100% - 16px);
            font-family: monospace; /* Better for URLs */
            word-break: break-all; /* Ensure long URLs wrap properly */
        }
        #createInviteBtn { width: 100%; margin-bottom: 10px;}
        .invite-row { display: flex; gap: 8px; margin-top: 8px; align-items: center; }
        .invite-row #inviteLink { width: auto; flex: 1; min-width: 0; }
        .invite-row button { padding: 8px 12px; }
        #userList { list-style-type: none; padding-left: 0; }
        #userList li { background-color: var(--primary-background); padding: 8px 12px; border-radius: 4px; margin-bottom: 5px; }
        .status { text-align: center; font-weight: bold; padding: 12px; border-radius: 6px; margin-top: 10px; }
        .status.connected { background-color: #d1e7dd; color: #0f5132; }
        .status.disconnected { background-color: #f8d7da; color: #842029; }
        .status.connecting { background-color: #fff3cd; color: #664d03; }
        button { background-color: var(--yt-red); color: white; padding: 10px 16px; border: none; border-radius: 40px; cursor: pointer; font-size: 14px; font-weight: 500; transition: background-color 0.2s; }
        button:hover { background-color: var(--yt-red-hover); }
        .chat-container { margin-top: 24px; }
        @media (min-width: 1024px) {
            .page-container { display: grid; grid-template-columns: 1fr 402px; gap: 24px; align-items: flex-start; }
            .chat-container { grid-column: 1 / 2; grid-row: 2 / 3; margin-top: 0; } /* rely on grid row gap */
        }
        .chat-messages { height: 300px; overflow-y: auto; border: 1px solid var(--border-color); background-color: var(--primary-background); padding: 10px; margin-bottom: 10px; border-radius: 8px; display: flex; flex-direction: column; gap: 16px; }
        .chat-message { display: flex; align-items: flex-start; gap: 12px; }
        .avatar { width: 40px; height: 40px; border-radius: 50%; color: white; display: flex; align-items: center; justify-content: center; font-weight: bold; flex-shrink: 0; font-size: 18px; }
        .message-body { display: flex; flex-direction: column; }
        .sender { font-weight: 500; font-size: 14px; margin-bottom: 2px; color: var(--primary-text); }
        .message-text { font-size: 14px; line-height: 1.4; color: var(--primary-text); }
        .chat-input-container { display: flex; gap: 8px; }
        #chatInput { flex-grow: 1; border-radius: 20px; background-color: var(--input-background); border: 1px solid var(--border-color); color: var(--primary-text); padding: 10px; }
        #sendChatBtn { padding: 10px 20px; }
        .player-controls { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; margin-top: 16px; background-color: var(--secondary-background); border: 1px solid var(--border-color); border-radius: 12px; }
        .video-title-toolbar { flex-grow: 1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; font-weight: bold; font-size: 16px; padding-right: 16px; }
        #theaterModeBtn { background: none; border: 1px solid var(--border-color); color: var(--primary-text); padding: 8px; border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center; z-index: 50; flex-shrink: 0; }
        #theaterModeBtn:hover { background-color: var(--hover-background); }
        #theaterModeBtn svg { stroke: var(--primary-text); }
        body.theater-mode .main-content { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background-color: #000; z-index: 500; padding: 0; margin: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        body.theater-mode .player-container { width: 100%; height: 100%; border-radius: 0; }
        /* Hide the toolbar in theater mode */
        body.theater-mode .player-controls { display: none; }
        body.theater-mode .header, body.theater-mode .sidebar, body.theater-mode .chat-container, body.theater-mode .page-container > .main-content ~ * { display: none; }
        .expand-icon { display: block; }
        .close-icon { display: none; }
        body.theater-mode .expand-icon { display: none; }
        body.theater-mode .close-icon { display: block; }
        .hidden { display: none !important; }

        /* Centered close button for theater mode */
        #theaterCloseBtn {
            position: fixed;
            top: 12px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1001;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 44px;
            height: 44px;
            padding: 0;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.25);
            background-color: rgba(0,0,0,0.6);
            color: #fff;
            cursor: pointer;
            backdrop-filter: blur(4px);
            /* fade behavior */
            opacity: 0;
            pointer-events: none;
            transition: opacity 180ms ease-in-out;
        }
        body.dark #theaterCloseBtn { border-color: rgba(255,255,255,0.25); }

        /* When theater UI should be visible */
        body.theater-mode.theater-ui-visible #theaterCloseBtn {
            opacity: 1;
            pointer-events: auto;
        }

        /* Transparent hover sensor to detect mouse movement over iframe */
        #theaterHoverSensor {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 96px; /* small strip */
            background: transparent;
            z-index: 1000; /* just under the close button */
            display: none;
        }
        body.theater-mode #theaterHoverSensor { display: block; }

        /* Up Next overlay */
        .upnext-overlay {
            position: absolute;
            inset: 0;
            z-index: 1002; /* above iframe and sensors */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 16px;
            background: linear-gradient(180deg, rgba(0,0,0,0.65), rgba(0,0,0,0.85));
            color: #fff;
            opacity: 0;
            pointer-events: none;
            transition: opacity 180ms ease-in-out;
            padding: 16px;
            text-align: center;
        }
        .upnext-overlay.active {
            opacity: 1;
            pointer-events: auto; /* block clicks to YouTube suggestions */
        }
        /* Ensure overlay captures clicks above the player iframe */
        .player-container.overlay-active #player,
        .player-container.overlay-active #player iframe {
            pointer-events: none !important;
        }

        /* Up Next grid layout */
        .upnext-title { font-size: 20px; font-weight: 600; }
        .upnext-grid {
            display: grid;
            grid-template-columns: repeat(2, minmax(0, 1fr));
            gap: 12px;
            width: 100%;
            max-width: 1100px;
            padding: 0 12px;
        }
        @media (min-width: 640px) {
            .upnext-grid { grid-template-columns: repeat(3, 1fr); }
        }
        @media (min-width: 1024px) {
            .upnext-grid { grid-template-columns: repeat(4, 1fr); }
        }
        .upnext-item {
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.15);
            border-radius: 10px;
            overflow: hidden;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            text-align: left;
            transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease;
        }
        .upnext-item:hover {
            transform: translateY(-2px);
            background: rgba(255,255,255,0.12);
            box-shadow: 0 6px 20px rgba(0,0,0,0.35);
        }
        .upnext-item:focus {
            outline: 2px solid rgba(255,255,255,0.35);
            outline-offset: -2px;
        }
        .upnext-thumb {
            width: 100%;
            aspect-ratio: 16 / 9;
            object-fit: cover;
            display: block;
            background: #000;
        }
        .upnext-info {
            padding: 8px 10px 10px;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .upnext-title-line {
            font-size: 14px;
            font-weight: 600;
            color: #fff;
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .upnext-meta {
            font-size: 12px;
            color: rgba(255,255,255,0.8);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
    </style>
</head>
<body>

<div class="user-modal" id="userModal">
    <div class="user-container">
        <h2>Welcome to YouTube Party</h2>
        <p>Please enter your name to join or start a party.</p>
        <input type="text" id="userName" placeholder="Enter your name...">
        <button id="setNameBtn" disabled>Continue</button>
    </div>
</div>

<div id="mainContent" class="hidden">
    <div class="header">
        <div class="logo-container">
            <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" fill="white" focusable="false"><path d="M10 16.5l6-4.5-6-4.5v9zM12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"></path></svg>
            <h1>YouTube Party</h1>
        </div>
        <div class="search-container-header">
            <input type="text" id="searchInput" placeholder="Search for a YouTube video...">
            <button id="searchButton">
                <svg xmlns="http://www.w3.org/2000/svg" height="24" viewBox="0 0 24 24" width="24" focusable="false"><path d="M20.87 20.17l-5.59-5.59C16.35 13.35 17 11.75 17 10c0-3.87-3.13-7-7-7s-7 3.13-7 7 3.13 7 7 7c1.75 0 3.35-.65 4.58-1.71l5.59 5.59.71-.71zM10 16c-3.31 0-6-2.69-6-6s2.69-6 6-6 6 2.69 6 6-2.69 6-6 6z"></path></svg>
            </button>
        </div>
        <div class="user-actions">
            <button id="darkModeToggle" title="Toggle dark mode">
                <svg class="sun-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
                <svg class="moon-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="white" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
            </button>
        </div>
    </div>
    
    <div class="page-container">
        <div class="main-content">
            <div class="player-container"><div id="player"></div>
                <!-- Up Next overlay -->
                <div id="upNextOverlay" class="upnext-overlay" aria-hidden="true">
                    <div class="upnext-title">Up next</div>
                    <div id="upNextList" class="upnext-grid"></div>
                    <div class="upnext-actions">
                        <button id="upNextReplayBtn" class="upnext-btn" title="Replay current video">Replay</button>
                        <button id="upNextCloseBtn" class="upnext-btn" title="Close">Close</button>
                    </div>
                    <div style="font-size:12px;opacity:.8;">Suggestions appear here when the queue is empty.</div>
                </div>
            </div>
            <div class="player-controls">
                <div id="videoTitle" class="video-title-toolbar">No video loaded</div>
                <button id="theaterModeBtn" title="Theater Mode">
                    <svg class="expand-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></svg>
                    <svg class="close-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>
                </button>
            </div>
        </div>

        <div class="sidebar">
            <div class="sidebar-section">
                <h2>Search</h2>
                <ul id="results"></ul>
            </div>
            
            <div class="sidebar-section">
                <h2>Queue</h2>
                <ul id="queueList"></ul>
            </div>

            <div class="sidebar-section">
                <h2>Party Sync</h2>
                <div id="connectionManagement">
                    <button id="createInviteBtn">Create Invite Link</button>
                    <!-- Inline invite link + Copy button -->
                    <div class="invite-row hidden" id="inviteRow">
                        <input type="text" id="inviteLink" readonly>
                        <button id="copyInviteBtn" aria-label="Copy invite link" title="Copy to clipboard">Copy</button>
                    </div>
                </div>
                <h3>Connected Users</h3>
                <ul id="userList"></ul>
                <div id="connectionStatus" class="status disconnected">Status: Disconnected</div>
            </div>
        </div>

        <div class="chat-container sidebar-section">
            <h3>Live Chat</h3>
            <div class="chat-messages" id="chatMessages"></div>
            <div class="chat-input-container">
                <input type="text" id="chatInput" placeholder="Say something...">
                <button id="sendChatBtn">Send</button>
            </div>
        </div>
    </div>
</div>

<!-- Transparent sensor to detect mouse movement near top in theater mode -->
<div id="theaterHoverSensor" aria-hidden="true"></div>

<!-- Centered close button (only used in theater mode) -->
<button id="theaterCloseBtn" aria-label="Exit Theater Mode" title="Exit Theater Mode">
    <!-- X icon -->
    <svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" focusable="false">
        <line x1="18" y1="6" x2="6" y2="18"></line>
        <line x1="6" y1="6" x2="18" y2="18"></line>
    </svg>
</button>

<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-functions-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-auth-compat.js"></script>
<script src="https://www.youtube.com/iframe_api"></script>

<script>
    // --- DARK MODE LOGIC ---
    const darkModeToggle = document.getElementById('darkModeToggle');
    if (localStorage.getItem('theme') === 'dark') {
        document.body.classList.add('dark');
    }
    darkModeToggle.addEventListener('click', () => {
        document.body.classList.toggle('dark');
        if (document.body.classList.contains('dark')) {
            localStorage.setItem('theme', 'dark');
        } else {
            localStorage.setItem('theme', 'light');
        }
    });

    // --- CONFIGURATION ---
    const firebaseConfig = {
        apiKey: "AIzaSyActKLRV4ldSsS1dKNwkXXdKblnwG0s654", 
        authDomain: "partysync-17cd5.firebaseapp.com",
        projectId: "partysync-17cd5",
        storageBucket: "partysync-17cd5.appspot.com",
        messagingSenderId: "294351433712",
        appId: "1:294351433712:web:826470510443b924a6b735",
        measurementId: "G-PF73SF4VGY"
    };

    // --- INITIALIZE FIREBASE ---
    const app = firebase.initializeApp(firebaseConfig);
    const db = app.firestore();

    // --- DOM ELEMENTS ---
    const userModal = document.getElementById('userModal');
    const userNameInput = document.getElementById('userName');
    const setNameBtn = document.getElementById('setNameBtn');
    const mainContent = document.getElementById('mainContent');
    const searchButton = document.getElementById('searchButton');
    const searchInput = document.getElementById('searchInput');
    const resultsList = document.getElementById('results');
    const queueList = document.getElementById('queueList');
    const connectionStatus = document.getElementById('connectionStatus');
    const createInviteBtn = document.getElementById('createInviteBtn');
    const inviteLinkInput = document.getElementById('inviteLink');
    const inviteRow = document.getElementById('inviteRow');
    const copyInviteBtn = document.getElementById('copyInviteBtn');
    const userList = document.getElementById('userList');
    const chatMessages = document.getElementById('chatMessages');
    const chatInput = document.getElementById('chatInput');
    const sendChatBtn = document.getElementById('sendChatBtn');
    const videoTitleElement = document.getElementById('videoTitle');

    // --- APP STATE ---
    let myName = '';
    let player;
    let isHost = false;
    let partyId = '';
    let myAuthId = null; 
    let currentHostId = '';
    const peerConnections = {};
    const dataChannels = {};
    let partyDocRef;
    let videoQueue = [];
    let isSyncingFromHost = false;
    let lastPlayerState = -1;
    let officialVideoDuration = 0;
    let hostHeartbeatInterval;
    let lastUserActionTimestamp = 0;
    let intentToAutoPlay = false;
    let localUserList = {};
    // Track real user gestures to distinguish auto-pauses on hidden tabs
    let lastUserGestureAt = 0;
    ['pointerdown','keydown','touchstart','click'].forEach(evt =>
        document.addEventListener(evt, () => { lastUserGestureAt = Date.now(); }, { passive: true })
    );
    // Track the currently loaded videoId
    let currentVideoId = null;

    // WebRTC configuration (add TURN here for reliability)
    const rtcConfig = {
        iceServers: [
            { urls: ['stun:stun.l.google.com:19302','stun:stun1.l.google.com:19302','stun:stun2.l.google.com:19302'] }
        ],
        iceCandidatePoolSize: 2,
        iceTransportPolicy: 'all'
    };

    // Helpful mapping for logging YT state numbers
    const YT_STATE = {
        [-1]: 'UNSTARTED',
        [0]: 'ENDED',
        [1]: 'PLAYING',
        [2]: 'PAUSED',
        [3]: 'BUFFERING',
        [5]: 'CUED',
    };

    // Up Next overlay elements
    const upNextOverlay = document.getElementById('upNextOverlay');
    const upNextList = document.getElementById('upNextList');
    const upNextCloseBtn = document.getElementById('upNextCloseBtn');
    const upNextReplayBtn = document.getElementById('upNextReplayBtn');
    let upNextActive = false;

    // Also grab the container to toggle a helper class
    const playerContainer = document.querySelector('.player-container');

    function showUpNextOverlay() {
        // Move overlay to be last child to sit above everything
        if (upNextOverlay.parentElement) {
            upNextOverlay.parentElement.appendChild(upNextOverlay);
        }
        upNextOverlay.classList.add('active');
        upNextOverlay.setAttribute('aria-hidden', 'false');
        // Inline fallbacks in case of CSS specificity issues
        upNextOverlay.style.opacity = '1';
        upNextOverlay.style.pointerEvents = 'auto';
        if (playerContainer) playerContainer.classList.add('overlay-active');
        upNextActive = true;
        console.log('[UpNext] Overlay shown');
    }
    function hideUpNextOverlay() {
        upNextOverlay.classList.remove('active');
        upNextOverlay.setAttribute('aria-hidden', 'true');
        upNextOverlay.style.opacity = '';
        upNextOverlay.style.pointerEvents = '';
        if (playerContainer) playerContainer.classList.remove('overlay-active');
        upNextActive = false;
        console.log('[UpNext] Overlay hidden');
    }
    async function populateUpNextSuggestions() {
        try {
            if (!player || !player.getVideoData) return;
            const data = player.getVideoData();
            const title = data?.title || '';
            const vid = data?.video_id || currentVideoId;
            currentVideoId = vid || currentVideoId;

            upNextList.innerHTML = '<div style="grid-column:1/-1;opacity:.8;">Loading suggestionsâ€¦</div>';

            // Call the Cloud Function to search by the current title (approximate related)
            const searchYoutubeFunction = app.functions('us-central1').httpsCallable('searchYoutube');
            const res = await searchYoutubeFunction({ query: title || 'YouTube' });
            const items = (res.data?.items || [])
                .map(it => {
                    const id = typeof it.id === 'object' ? it.id.videoId : it.id;
                    return {
                        videoId: id,
                        title: it.snippet?.title || '',
                        channel: it.snippet?.channelTitle || '',
                        thumb: it.snippet?.thumbnails?.medium?.url || it.snippet?.thumbnails?.default?.url
                    };
                })
                .filter(v => v.videoId && v.videoId !== vid)
                .slice(0, 8);

            if (!items.length) {
                upNextList.innerHTML = '<div style="grid-column:1/-1;opacity:.8;">No suggestions found.</div>';
                return;
            }

            upNextList.innerHTML = '';
            for (const it of items) {
                const card = document.createElement('div');
                card.className = 'upnext-item';
                card.setAttribute('role', 'button');
                card.setAttribute('tabindex', '0');
                card.setAttribute('aria-label', `Play ${it.title}`);
                card.innerHTML = `
                    <img class="upnext-thumb" src="${it.thumb}" alt="">
                    <div class="upnext-info">
                        <div class="upnext-title-line" title="${it.title}">${it.title}</div>
                        <div class="upnext-meta" title="${it.channel}">${it.channel}</div>
                    </div>
                `;
                const playSelected = () => {
                    hideUpNextOverlay();
                    handleUserAction({ type: 'NEW_VIDEO', videoId: it.videoId, autoPlay: true });
                };
                card.addEventListener('click', playSelected);
                card.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        playSelected();
                    }
                });
                upNextList.appendChild(card);
            }
        } catch (e) {
            console.warn('Failed to load suggestions', e);
            upNextList.innerHTML = '<div style="grid-column:1/-1;opacity:.8;">Failed to load suggestions.</div>';
        }
    }

    upNextCloseBtn.addEventListener('click', hideUpNextOverlay);
    upNextReplayBtn.addEventListener('click', () => {
        if (currentVideoId) {
            hideUpNextOverlay();
            handleUserAction({ type: 'NEW_VIDEO', videoId: currentVideoId, autoPlay: true });
        }
    });

    // Intercept YouTube suggestion clicks that try to open a new tab and play them in-app instead
    (function installYouTubeOpenInterceptor() {
        const originalOpen = window.open ? window.open.bind(window) : null;
        function extractYouTubeVideoId(urlLike) {
            try {
                const urlStr = String(urlLike);
                const re = /(?:v=|\/shorts\/|youtu\.be\/)([A-Za-z0-9_-]{11})/;
                const m = urlStr.match(re);
                if (m && m[1]) return m[1];
                const u = new URL(urlStr, window.location.href);
                const host = u.hostname.replace(/^www\./, '');
                if (host.endsWith('youtu.be')) {
                    const parts = u.pathname.split('/').filter(Boolean);
                    if (parts[0] && parts[0].length === 11) return parts[0];
                }
                if (host.endsWith('youtube.com')) {
                    if (u.pathname.startsWith('/shorts/')) {
                        const id = u.pathname.split('/')[2] || u.pathname.split('/')[1];
                        if (id && id.length === 11) return id;
                    }
                    const v = u.searchParams.get('v');
                    if (v && v.length === 11) return v;
                }
            } catch (_) {}
            return null;
        }
        window.open = function(url, target, features) {
            const vid = extractYouTubeVideoId(url);
            if (vid) {
                try {
                    handleUserAction({ type: 'NEW_VIDEO', videoId: vid, autoPlay: true });
                    return null;
                } catch (e) {
                    return originalOpen ? originalOpen(url, target, features) : null;
                }
            }
            return originalOpen ? originalOpen(url, target, features) : null;
        };
    })();

    // --- AUTHENTICATION & APP START ---
    firebase.auth().onAuthStateChanged(user => {
        if (user) {
            myAuthId = user.uid;
            console.log("User signed in with UID:", myAuthId);
            setNameBtn.disabled = false;
        } else {
            myAuthId = null;
            setNameBtn.disabled = true;
        }
    });

    setNameBtn.disabled = true;
    firebase.auth().signInAnonymously().catch((error) => {
        console.error("Anonymous sign-in failed:", error);
        alert("Could not connect to the service. Please refresh the page.");
    });

    // --- INITIALIZATION ---
    setNameBtn.addEventListener('click', () => {
        const name = userNameInput.value.trim();
        if (name && myAuthId) {
            myName = name;
            userModal.classList.add('hidden');
            mainContent.classList.remove('hidden');
            initApp();
        } else if (!name) {
            alert('Please enter a name.');
        } else {
            alert('Could not verify connection. Please refresh the page.');
        }
    });

    function initApp() {
        const urlParams = new URLSearchParams(window.location.search);
        partyId = urlParams.get('party');
        if (partyId) {
            isHost = false;
            createInviteBtn.classList.add('hidden');
            // Detect if you opened the guest link as the same signed-in user as the host
            (async () => {
                try {
                    const partySnap = await db.collection('parties').doc(partyId).get();
                    const hostIdFromDoc = partySnap.data()?.hostId;
                    if (hostIdFromDoc && hostIdFromDoc === myAuthId) {
                        console.warn('[JOIN] Same UID as host. Use a different browser profile/incognito for the guest.');
                        alert('You are joining with the same account as the host. Open the invite in a different browser or an incognito window so the guest has a different UID.');
                    }
                } catch (e) {
                    console.warn('Could not verify hostId before joining:', e);
                } finally {
                    joinParty();
                }
            })();
        } else {
            isHost = true;
            startHostHeartbeat();
        }
        sendChatBtn.addEventListener('click', sendChatMessage);
        chatInput.addEventListener('keypress', e => {
            if (e.key === 'Enter') sendChatMessage();
        });
        // Enhanced leaving detection - multiple methods for reliability
        const sendLeavingMessage = () => {
            const data = { type: 'USER_LEAVING' };
            Object.values(dataChannels).forEach(channel => {
                if (channel && channel.readyState === 'open') {
                    try {
                        channel.send(JSON.stringify(data));
                    } catch (e) {
                        console.warn('Error sending leaving message:', e);
                    }
                }
            });
        };

        // Method 1: beforeunload event
        window.addEventListener('beforeunload', sendLeavingMessage);
        
        // Method 2: pagehide event (more reliable on mobile)
        window.addEventListener('pagehide', sendLeavingMessage);
        
        // Method 3: visibilitychange when document becomes hidden for extended period
        let hiddenTimeout;
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Set a timeout to send leaving message if hidden for too long
                hiddenTimeout = setTimeout(() => {
                    console.log('[CLEANUP] Tab hidden for 30 seconds, sending leaving message');
                    sendLeavingMessage();
                }, 30000); // 30 seconds
            } else {
                // Tab became visible again, cancel the timeout
                if (hiddenTimeout) {
                    clearTimeout(hiddenTimeout);
                    hiddenTimeout = null;
                }
            }
        });

        // Handle visibility changes to prevent auto-pause when tab loses focus
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden && player) {
                // When tab becomes visible again, check if video should be playing
                const state = player.getPlayerState();
                console.log('[YT] Tab became visible, current state:', state);
            } else if (document.hidden && player) {
                // When tab becomes hidden, prevent auto-pause
                console.log('[YT] Tab became hidden, preventing auto-pause');
                
                // If video is currently playing, keep it playing
                setTimeout(() => {
                    const state = player.getPlayerState();
                    if (state === YT.PlayerState.PAUSED && !isManualPause) {
                        console.log('[YT] Detected auto-pause from hidden tab, resuming playback');
                        player.playVideo();
                    }
                }, 100); // Small delay to catch the browser's auto-pause
            }
        });

        // Add periodic cleanup for stale connections (every 2 minutes)
        setInterval(() => {
            if (isHost) {
                let removedUsers = [];
                
                // Check for disconnected peer connections
                Object.entries(peerConnections).forEach(([peerId, pc]) => {
                    if (pc.connectionState === 'closed' || pc.connectionState === 'failed') {
                        console.log(`[CLEANUP] Removing stale connection: ${peerId}`);
                        
                        // Clean up
                        delete peerConnections[peerId];
                        delete dataChannels[peerId];
                        delete localUserList[peerId];
                        delete guestTimePositions[peerId]; // Clean up position tracking
                        removedUsers.push(peerId);
                        
                        // Clean up Firestore
                        if (partyDocRef) {
                            partyDocRef.collection('guests').doc(peerId).delete().catch(error => 
                                console.error("Error removing stale guest document:", error)
                            );
                        }
                    }
                });
                
                // If we removed anyone, update the user list
                if (removedUsers.length > 0) {
                    console.log(`[CLEANUP] Removed ${removedUsers.length} stale connections`);
                    
                    const users = { [myAuthId]: { name: myName } };
                    Object.entries(peerConnections).forEach(([id, pc]) => {
                        if (pc.peerName) users[id] = { name: pc.peerName };
                    });
                    localUserList = users;
                    broadcastData({ type: 'USER_LIST', users });
                    updateUserList(localUserList);
                }
                
                // Also clean up old guest time positions (older than 30 seconds)
                const now = Date.now();
                Object.keys(guestTimePositions).forEach(guestId => {
                    if (now - guestTimePositions[guestId].timestamp > 30000) {
                        delete guestTimePositions[guestId];
                    }
                });
            }
        }, 120000); // 2 minutes

        // Add periodic check to prevent auto-pause when tab is hidden
        setInterval(() => {
            if (document.hidden && player && typeof player.getPlayerState === 'function') {
                const state = player.getPlayerState();
                
                // If video is paused but it shouldn't be (not a manual pause), resume it
                if (state === YT.PlayerState.PAUSED && !isManualPause) {
                    console.log('[YT] Periodic check: resuming auto-paused video in hidden tab');
                    player.playVideo();
                }
            }
        }, 1000); // Check every second
    }

    // Enhanced ad detection and skipping system
    function checkAndSkipAds() {
        if (!player || typeof player.getDuration !== 'function') return;
        
        const currentDuration = player.getDuration();
        const currentTime = player.getCurrentTime();
        const now = Date.now();
        
        // Skip if we just tried to skip (prevent spam)
        if (now - lastAdSkipTime < 2000) return;
        
        // Ad detection criteria:
        // 1. Duration is significantly different from expected (officialVideoDuration)
        // 2. We have an expected duration (not a new video)
        // 3. Current duration suggests an ad (typically 15-30 seconds for ads vs 3+ minutes for content)
        const hasExpectedDuration = officialVideoDuration > 0;
        const durationMismatch = Math.abs(currentDuration - officialVideoDuration) > 10;
        const likelyAd = currentDuration > 0 && currentDuration < 120; // Ads are usually under 2 minutes
        const contentVideo = officialVideoDuration > 120; // Content is usually over 2 minutes
        
        if (hasExpectedDuration && durationMismatch && likelyAd && contentVideo) {
            console.log(`[AD-SKIP] Detected ad: duration ${currentDuration}s vs expected ${officialVideoDuration}s`);
            attemptAdSkip();
        }
    }
    
    function attemptAdSkip() {
        const now = Date.now();
        lastAdSkipTime = now;
        adSkipAttempts++;
        
        console.log(`[AD-SKIP] Attempting to skip ad (attempt ${adSkipAttempts})`);
        
        // Method 1: Try to click the skip button
        const skipButton = document.querySelector('.ytp-ad-skip-button, .ytp-skip-ad-button, .ytp-ad-skip-button-modern');
        if (skipButton && skipButton.offsetParent !== null) {
            console.log('[AD-SKIP] Found skip button, clicking');
            skipButton.click();
            return;
        }
        
        // Method 2: Try to seek to the end of the ad
        if (player && typeof player.getDuration === 'function') {
            const duration = player.getDuration();
            if (duration > 0 && duration < 120) {
                console.log('[AD-SKIP] Seeking to end of ad');
                player.seekTo(duration - 0.1, true);
                return;
            }
        }
        
        // Method 3: Try to reload the video (last resort)
        if (adSkipAttempts >= 3 && currentVideoId) {
            console.log('[AD-SKIP] Multiple skip attempts failed, reloading video');
            const currentTime = getExpectedCurrentTime();
            player.loadVideoById(currentVideoId, currentTime);
            adSkipAttempts = 0; // Reset counter
        }
    }
    
    function getExpectedCurrentTime() {
        // For hosts: use their current position
        if (isHost) {
            return player.getCurrentTime();
        }
        
        // For guests: estimate based on when the video started playing
        // This is a fallback - in practice, sync will handle this
        if (officialVideoDuration > 0) {
            return Math.min(player.getCurrentTime(), officialVideoDuration);
        }
        
        return 0;
    }

    // Enhanced TIME_UPDATE handling for ad detection
    function handleTimeUpdate() {
        if (!isHost || !player) return;
        
        // Check for ads during time updates too
        checkAndSkipAds();
        
        const currentState = player.getPlayerState();
        const hostTime = player.getCurrentTime();
        
        // Broadcast time updates to guests for synchronization
        if (currentState === YT.PlayerState.PLAYING) {
            broadcastData({ 
                type: 'TIME_UPDATE', 
                time: hostTime,
                duration: player.getDuration(),
                state: currentState 
            });
        }
    }

    // --- THEATER MODE ---
    const theaterModeBtn = document.getElementById('theaterModeBtn');
    const theaterCloseBtn = document.getElementById('theaterCloseBtn');
    const theaterHoverSensor = document.getElementById('theaterHoverSensor');
    let theaterUiHideTimer;

    function showTheaterUiTemporarily(delayMs = 3000) {
        document.body.classList.add('theater-ui-visible');
        clearTimeout(theaterUiHideTimer);
        theaterUiHideTimer = setTimeout(() => {
            document.body.classList.remove('theater-ui-visible');
        }, delayMs);
    }

    function theaterActivityPing() {
        if (!document.body.classList.contains('theater-mode')) return;
        showTheaterUiTemporarily();
    }

    function disableTheaterUi() {
        clearTimeout(theaterUiHideTimer);
        document.body.classList.remove('theater-ui-visible');
        document.removeEventListener('mousemove', theaterActivityPing);
        document.removeEventListener('keydown', theaterActivityPing);
        document.removeEventListener('wheel', theaterActivityPing, { passive: true });
        document.removeEventListener('touchstart', theaterActivityPing, { passive: true });
        theaterHoverSensor.removeEventListener('mousemove', theaterActivityPing);
        theaterHoverSensor.removeEventListener('mouseenter', theaterActivityPing);
        theaterCloseBtn.removeEventListener('click', exitTheaterMode);
    }

    function enableTheaterUi() {
        showTheaterUiTemporarily();
        // Re-show on user activity (mouse over doc, top sensor, keys, wheel, touch)
        document.addEventListener('mousemove', theaterActivityPing);
        document.addEventListener('keydown', theaterActivityPing);
        document.addEventListener('wheel', theaterActivityPing, { passive: true });
        document.addEventListener('touchstart', theaterActivityPing, { passive: true });
        theaterHoverSensor.addEventListener('mousemove', theaterActivityPing);
        theaterHoverSensor.addEventListener('mouseenter', theaterActivityPing);
        theaterCloseBtn.addEventListener('click', exitTheaterMode);
    }

    function exitTheaterMode() {
        document.body.classList.remove('theater-mode');
        theaterModeBtn.title = 'Theater Mode';
        disableTheaterUi();
    }

    theaterModeBtn.addEventListener('click', () => {
        document.body.classList.toggle('theater-mode');
        const inTheaterMode = document.body.classList.contains('theater-mode');
        theaterModeBtn.title = inTheaterMode ? 'Exit Theater Mode' : 'Theater Mode';
        if (inTheaterMode) {
            enableTheaterUi();
        } else {
            disableTheaterUi();
        }
    });

    // Allow Esc to exit theater mode
    document.addEventListener('keydown', (event) => {
        if (event.key === 'Escape' && document.body.classList.contains('theater-mode')) {
            exitTheaterMode();
        }
    });

    // --- YOUTUBE API ---
    window.onYouTubeIframeAPIReady = () => {
        player = new YT.Player('player', {
            videoId: '',
            playerVars: {
                rel: 0,
                playsinline: 1,
                modestbranding: 1,
                origin: window.location.origin
            },
            events: { 
                'onStateChange': onPlayerStateChange,
                'onReady': () => {
                    console.log('[YT] Player ready');
                    playerReady = true;
                    // Process any buffered messages
                    console.log(`[YT] Processing ${pendingMessages.length} buffered messages`);
                    while (pendingMessages.length > 0) {
                        const { data, senderId } = pendingMessages.shift();
                        handleReceivedData(data, senderId);
                    }
                }
            }
        });
    };
    searchButton.addEventListener('click', searchYouTube);
    searchInput.addEventListener('keypress', e => e.key === 'Enter' && searchYouTube());

    async function searchYouTube() {
		const query = searchInput.value;
		if (!query) return;

		// This regular expression checks for various YouTube URL formats and extracts the video ID.
		const youtubeUrlRegex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([\w-]{11})/;
		const match = query.match(youtubeUrlRegex);
		
		let payload = {};
		if (match) {
			// If it's a URL, the payload will contain the video ID.
			const videoId = match[1];
			payload = { videoId: videoId };
			console.log("YouTube URL detected. Fetching by video ID:", videoId);
		} else {
			// Otherwise, it's a regular search query.
			payload = { query: query };
			console.log("Performing keyword search for:", query);
		}

		const searchYoutubeFunction = app.functions('us-central1').httpsCallable('searchYoutube');
		try {
			const result = await searchYoutubeFunction(payload);
			displayResults(result.data.items || []);
		} catch (error) {
			console.error("Error calling Cloud Function:", error);
			alert("Could not fetch results. Check the console for details.");
		}
	}

    function displayResults(videos) {
		resultsList.innerHTML = videos.length ? '' : '<li>No videos found.</li>';
		videos.forEach(video => {
			// --- THIS IS THE FIX ---
			// The video ID is in a different place depending on the API call.
			// If video.id is an object, it's a search result. If not, it's a direct lookup.
			const videoId = (typeof video.id === 'object') ? video.id.videoId : video.id;

			const title = video.snippet.title;
			const thumbnailUrl = video.snippet.thumbnails.default.url;

			const li = document.createElement('li');
			li.dataset.videoId = videoId;
			li.innerHTML = `<img src="${thumbnailUrl}" alt="${video.title}"><div class="video-info"><div class="video-title" title="Play Now">${title}</div><button class="queue-btn">Add</button></div>`;
			
			const clickableElements = [li.querySelector('img'), li.querySelector('.video-title')];
			clickableElements.forEach(el => el.addEventListener('click', () => {
				if (videoId) { // Ensure we have a valid videoId before trying to play
					handleUserAction({ type: 'NEW_VIDEO', videoId: videoId, autoPlay: true });
				}
			}));

			li.querySelector('.queue-btn').addEventListener('click', (e) => {
				e.stopPropagation();
				if (videoId) { // Ensure we have a valid videoId before queuing
					const videoData = { videoId, title, thumbnailUrl };
					handleUserAction({ type: 'ADD_TO_QUEUE', video: videoData });
				}
			});
			
			resultsList.appendChild(li);
		});
	}

    // --- WEBRTC & FIREBASE SIGNALING ---
    createInviteBtn.addEventListener('click', async () => {
        if (!myAuthId) return alert("Cannot create party, not connected.");
        isHost = true;
        partyId = crypto.randomUUID();
        currentHostId = myAuthId;
        const url = `${window.location.href.split('?')[0]}?party=${partyId}`;
        inviteLinkInput.value = url;
        // Show inline row with copy button
        inviteRow.classList.remove('hidden');
        copyInviteBtn.disabled = false;
        copyInviteBtn.textContent = 'Copy';

        createInviteBtn.disabled = true;
        partyDocRef = db.collection('parties').doc(partyId);
        try {
            await partyDocRef.set({
                hostId: myAuthId,
                createdAt: firebase.firestore.FieldValue.serverTimestamp()
            });
            console.log('[HOST] Created party doc', partyId);
        } catch (e) {
            console.error('[HOST] Failed to create party doc:', e);
            alert('Could not create party in Firestore. Check Firestore rules and console.');
            return;
        }
        listenForGuests();
        startHostHeartbeat();
    });

    async function joinParty() {
        if (!myAuthId) return alert("Cannot join party, not connected.");
        partyDocRef = db.collection('parties').doc(partyId);
        const guestDocRef = partyDocRef.collection('guests').doc(myAuthId);
        console.log('[JOIN] Starting joinParty for', myAuthId, 'party:', partyId);

        const pc = createPeerConnection('host');
        const candidateBuffer = [];
        let candidateTimer = null;

        // Keep refs on the pc for ICE restarts
        pc._guestDocRef = guestDocRef;
        pc._guestGuestCandidatesRef = guestDocRef.collection('guestCandidates');
        pc._guestHostCandidatesRef = guestDocRef.collection('hostCandidates');

        dataChannels['host'] = pc.createDataChannel('sync-channel');
        console.log('[JOIN] Created data channel to host');
        configureDataChannel('host', dataChannels['host']);

        const guestCandidatesRef = pc._guestGuestCandidatesRef;

        pc.onicecandidate = async (event) => {
            if (event.candidate) {
                try {
                    await guestCandidatesRef.add(event.candidate.toJSON());
                    console.log('[JOIN] Sent guest ICE candidate');
                } catch (e) {
                    console.error('[JOIN] Failed to write guest ICE candidate:', e);
                }
            } else {
                console.log('[JOIN] ICE gathering complete');
            }
        };

        try {
            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            console.log('[JOIN] Created offer');
            await guestDocRef.set({ offer, name: myName });
            console.log('[JOIN] Wrote offer to Firestore');
        } catch (e) {
            console.error('[JOIN] Failed to create/send offer:', e);
            alert('Could not join the party (offer failed). Check console for details.');
            return;
        }

        guestDocRef.onSnapshot(async (snapshot) => {
            const data = snapshot.data();
            if (!data) return;
            // Apply the host's answer only once and only in have-local-offer state
            if (data.answer && !pc._answerApplied && pc.signalingState === 'have-local-offer') {
                try {
                    await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
                    pc._answerApplied = true;
                    console.log('[JOIN] Set remote description (answer) from host');
                    candidateBuffer.forEach(c => pc.addIceCandidate(new RTCIceCandidate(c)).catch(err => console.error('[JOIN] addIceCandidate (buffer) failed:', err)));
                    candidateBuffer.length = 0;
                } catch (e) {
                    console.error('[JOIN] Failed to set remote description:', e);
                }
            }
        });

        pc._guestHostCandidatesRef.onSnapshot(snapshot => {
            snapshot.docChanges().forEach(change => {
                if (change.type === 'added') {
                    const candidate = change.doc.data();
                    if (pc.currentRemoteDescription) {
                        pc.addIceCandidate(new RTCIceCandidate(candidate))
                          .then(() => console.log('[JOIN] Added host ICE candidate'))
                          .catch(err => console.error('[JOIN] addIceCandidate failed:', err));
                    } else {
                        console.log('[JOIN] Buffering host ICE candidate (no remote desc yet)');
                        candidateBuffer.push(candidate);
                    }
                }
            });
        });
    }

    function listenForGuests() {
        console.log('[HOST] Listening for guests on party', partyId);
        partyDocRef.collection('guests').onSnapshot(async snapshot => {
            for (const change of snapshot.docChanges()) {
                const doc = change.doc;
                const guestId = doc.id;
                const data = doc.data() || {};
                if (change.type === 'added') {
                    const { offer, name } = data;
                    console.log('[HOST] Guest added:', guestId, 'name:', name);
                    // If someone joins with same UID as the host, refuse (they share auth state)
                    if (guestId === myAuthId) {
                        console.warn('[HOST] Ignoring guest with same UID as host. Use a different browser/incognito for guests.');
                        continue;
                    }
                    if (peerConnections[guestId]) continue;

                    try {
                        const guestDocRef = doc.ref;
                        const pc = createPeerConnection(guestId, name);
                        pc._hostGuestDocRef = guestDocRef;

                        pc.ondatachannel = event => {
                            console.log('[HOST] Data channel from guest', guestId);
                            dataChannels[guestId] = event.channel;
                            configureDataChannel(guestId, event.channel, name);
                        };

                        pc.onicecandidate = async (event) => {
                            if (event.candidate) {
                                try {
                                    await guestDocRef.collection('hostCandidates').add(event.candidate.toJSON());
                                    console.log('[HOST] Sent host ICE candidate to', guestId);
                                } catch (e) {
                                    console.error('[HOST] Failed to write host ICE candidate:', e);
                                }
                            } else {
                                console.log('[HOST] ICE gathering complete for', guestId);
                            }
                        };

                        await pc.setRemoteDescription(new RTCSessionDescription(offer));
                        console.log('[HOST] Set remote description (offer) from', guestId);
                        const answer = await pc.createAnswer();
                        await pc.setLocalDescription(answer);
                        console.log('[HOST] Created answer for', guestId);
                        await guestDocRef.update({ answer });
                        console.log('[HOST] Wrote answer for', guestId);

                        guestDocRef.collection('guestCandidates').onSnapshot(snap => {
                            snap.docChanges().forEach(ch => {
                                if (ch.type === 'added') {
                                    const cand = ch.doc.data();
                                    pc.addIceCandidate(new RTCIceCandidate(cand))
                                      .then(() => console.log('[HOST] Added guest ICE candidate', guestId))
                                      .catch(err => console.error('[HOST] addIceCandidate failed:', err));
                                }
                            });
                        });
                    } catch (e) {
                        console.error('[HOST] Error handling new guest', guestId, e);
                    }
                } else if (change.type === 'modified') {
                    // Handle ICE-restart offers from guest with throttling
                    try {
                        const pc = peerConnections[guestId];
                        if (!pc) continue;
                        
                        const now = Date.now();
                        
                        // Throttle restart responses to prevent loops
                        if (pc._lastRestartResponse && (now - pc._lastRestartResponse) < 5000) {
                            console.log('[HOST] Restart response throttled for', guestId);
                            continue;
                        }
                        
                        if (data.offer && data.restartedAt && pc.signalingState !== 'have-remote-offer') {
                            // Only process if this is a newer restart attempt
                            if (!pc._lastProcessedRestart || data.restartedAt > pc._lastProcessedRestart) {
                                console.log('[HOST] Guest', guestId, 'sent ICE-restart offer; answering...');
                                await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                                const answer = await pc.createAnswer();
                                await pc.setLocalDescription(answer);
                                await doc.ref.update({ answer });
                                console.log('[HOST] Wrote restart answer for', guestId);
                                
                                pc._lastRestartResponse = now;
                                pc._lastProcessedRestart = data.restartedAt;
                            } else {
                                console.log('[HOST] Ignoring duplicate restart from', guestId);
                            }
                        }
                    } catch (e) {
                        console.error('[HOST] Failed to process modified guest doc:', guestId, e);
                    }
                }
            }
        });
    }

    function createPeerConnection(peerId, peerName) {
        // Remove this problematic check that's blocking guest connections
        // if (hostMigrationInProgress) {
        //     console.log('[RTC] Skipping connection creation during migration');
        //     return null;
        // }
        
        const pc = new RTCPeerConnection(rtcConfig);
        peerConnections[peerId] = pc;
        pc.peerName = peerName;
        pc.peerId = peerId;

        let disconnectTimer = null;

        pc.onconnectionstatechange = () => {
            // Throttle logging to reduce spam
            const now = Date.now();
            if (!pc._lastStateLog || (now - pc._lastStateLog) > 2000) {
                console.log(`[RTC:${peerId}] connectionState=`, pc.connectionState);
                pc._lastStateLog = now;
            }
            updateConnectionStatus();
            
            // Handle host disconnection more aggressively
            if (peerId === 'host' && !isHost) {
                const state = pc.connectionState;
                
                if (state === 'failed' || state === 'disconnected' || state === 'closed') {
                    console.warn(`[RTC:host] Connection lost (${state}), starting migration`);
                    
                    // Reset migration flag if it was stuck
                    if (hostMigrationInProgress) {
                        console.warn('[MIGRATION] Resetting stuck migration flag');
                        hostMigrationInProgress = false;
                    }
                    
                    // Start migration after a short delay to avoid race conditions
                    setTimeout(() => {
                        if (!hostMigrationInProgress && pc.connectionState !== 'connected') {
                            handleHostDisconnection();
                        }
                    }, 1000);
                }
            }
        };

        pc.oniceconnectionstatechange = () => {
            // Throttle logging
            const now = Date.now();
            if (!pc._lastIceStateLog || (now - pc._lastIceStateLog) > 2000) {
                console.log(`[RTC:${peerId}] iceConnectionState=`, pc.iceConnectionState);
                pc._lastIceStateLog = now;
            }
            
            if (pc.iceConnectionState === 'disconnected') {
                clearTimeout(disconnectTimer);
                disconnectTimer = setTimeout(() => {
                    if (pc.iceConnectionState === 'disconnected') {
                        console.warn(`[RTC:${peerId}] Still disconnected; attempting ICE restart (guest side only).`);
                        attemptGuestIceRestart(pc);
                    }
                }, 5000); // Increased from 2000ms to 5000ms
            } else if (pc.iceConnectionState === 'failed') {
                console.warn(`[RTC:${peerId}] ICE failed. You likely need a TURN server.`);
            } else if (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed') {
                clearTimeout(disconnectTimer);
            }
        };
        // Remove excessive signaling state logging completely
        pc.onsignalingstatechange = () => {
            // Only log significant state changes
            if (pc.signalingState === 'stable' || pc.signalingState === 'closed') {
                console.log(`[RTC:${peerId}] signalingState=`, pc.signalingState);
            }
        };
        // Remove ICE gathering state logging completely
        pc.onicegatheringstatechange = () => {
            // Only log completion
            if (pc.iceGatheringState === 'complete') {
                console.log(`[RTC:${peerId}] iceGatheringState= complete`);
            }
        };
        return pc;
    }
    
    // Guest-side ICE restart helper
    async function attemptGuestIceRestart(pc) {
        // Only guests restart toward the host
        if (isHost || pc.peerId !== 'host') return;
        if (!pc._guestDocRef) return;
        
        // Add throttling to prevent restart loops
        const now = Date.now();
        if (pc._lastRestartAttempt && (now - pc._lastRestartAttempt) < 10000) {
            console.log('[JOIN] ICE restart throttled (last attempt too recent)');
            return;
        }
        
        if (pc._iceRestartInProgress) {
            console.log('[JOIN] ICE restart already in progress; skipping.');
            return;
        }
        if (pc.signalingState === 'closed') {
            console.warn('[JOIN] ICE restart skipped; connection already closed.');
            return;
        }
        
        // Check connection state - only restart if truly failed/disconnected
        if (pc.connectionState !== 'failed' && pc.iceConnectionState !== 'failed' && pc.iceConnectionState !== 'disconnected') {
            console.log('[JOIN] ICE restart skipped; connection not in failed state');
            return;
        }
        
        pc._iceRestartInProgress = true;
        pc._lastRestartAttempt = now;
        
        try {
            console.log('[JOIN] Attempting ICE restart...');
            // Create a new offer with iceRestart
            const offer = await pc.createOffer({ iceRestart: true });
            await pc.setLocalDescription(offer);
            // Clear old answer so host will respond with a fresh answer
            await pc._guestDocRef.update({
                offer,
                restartedAt: now,
                answer: firebase.firestore.FieldValue.delete()
            });
            console.log('[JOIN] Wrote restart offer');
        } catch (e) {
            console.error('[JOIN] ICE restart failed:', e);
        } finally {
            pc._iceRestartInProgress = false;
        }
    }

    // Utility: delete all docs in a subcollection (candidates)
    async function clearCollection(colRef) {
        try {
            const snap = await colRef.get();
            if (snap.empty) return;
            const batch = db.batch();
            snap.forEach(doc => batch.delete(doc.ref));
            await batch.commit();
        } catch (e) {
            console.warn('clearCollection failed:', e);
        }
    }

    function resetPartyState() {
        console.log("Resetting party state...");
        for (const peerId in peerConnections) {
            if (peerConnections[peerId]) {
                peerConnections[peerId].close();
            }
        }
        Object.keys(peerConnections).forEach(key => delete peerConnections[key]);
        Object.keys(dataChannels).forEach(key => delete dataChannels[key]);
        userList.innerHTML = '';
        localUserList = {};
        window.migrationInProgress = false;
    }

    const userColors = ['#ff7675', '#74b9ff', '#55efc4', '#ffeaa7', '#a29bfe', '#fd79a8', '#00cec9', '#fab1a0'];
    const getUserColor = (userName) => {
        let hash = 0;
        for (let i = 0; i < userName.length; i++) {
            hash = userName.charCodeAt(i) + ((hash << 5) - hash);
        }
        return userColors[Math.abs(hash % userColors.length)];
    };

    function sendChatMessage() {
        const text = chatInput.value.trim();
        if (text) {
            const messageData = { type: 'CHAT_MESSAGE', text: text, sender: myName };
            Object.values(dataChannels).forEach(channel => {
                if (channel && channel.readyState === 'open') {
                    channel.send(JSON.stringify(messageData));
                }
            });
            displayChatMessage(messageData);
            chatInput.value = '';
        }
    }

    function displayChatMessage({ text, sender }) {
        const messageEl = document.createElement('div');
        messageEl.classList.add('chat-message');
        const avatarEl = document.createElement('div');
        avatarEl.classList.add('avatar');
        avatarEl.textContent = sender.charAt(0).toUpperCase();
        avatarEl.style.backgroundColor = getUserColor(sender);
        const messageBodyEl = document.createElement('div');
        messageBodyEl.classList.add('message-body');
        const senderEl = document.createElement('div');
        senderEl.classList.add('sender');
        senderEl.textContent = sender;
        const textEl = document.createElement('div');
        textEl.classList.add('message-text');
        textEl.textContent = text;
        messageBodyEl.appendChild(senderEl);
        messageBodyEl.appendChild(textEl);
        messageEl.appendChild(avatarEl);
        messageEl.appendChild(messageBodyEl);
        chatMessages.appendChild(messageEl);
        chatMessages.scrollTop = chatMessages.scrollHeight;
    }

    // Add this variable declaration around line 580, with the other state variables:
let hostMigrationInProgress = false;
let hostMigrationTimeout = null;
let hostElectionLock = null;
let playerReady = false;
let pendingMessages = [];
let loadingNewVideo = false;
let isManualPause = false;
let guestTimePositions = {}; // Track guest positions for reverse sync
let adSkipAttempts = 0; // Track ad skip attempts
let lastAdSkipTime = 0; // Prevent spam clicking

    function handleUserAction(data) {
        // Clear sync flag for any user-initiated action
        if (data.userInitiated) {
            isSyncingFromHost = false;
        }
        
        // If guest is loading a NEW_VIDEO, load it locally first to prevent sync conflicts
        if (!isHost && data.type === 'NEW_VIDEO') {
            console.log('[DATA] Guest loading video locally first:', data.videoId);
            loadingNewVideo = true;
            currentVideoId = data.videoId;
            hideUpNextOverlay();
            updateVideoTitle();
            
            // Load the video immediately for the guest
            if (player && typeof player.loadVideoById === 'function') {
                player.loadVideoById(data.videoId);
                if (data.autoPlay) {
                    // Set a flag to auto-play once loaded
                    setTimeout(() => {
                        if (player.getPlayerState() === YT.PlayerState.CUED) {
                            player.playVideo();
                        }
                    }, 1000);
                }
            }
        }
        
        if (isHost) {
            broadcastData(data);
        } else {
            sendRequestToHost(data);
        }
    }

    function sendRequestToHost(data) {
        if (isHost) return;

        if (data.type === 'STATE_CHANGE') {
            // Check if we should suppress this state change due to recent sync from host
            if (isSyncingFromHost && !data.userInitiated) {
                console.log('[DATA] Suppressing non-user state change during host sync');
                // Reset sync flag after a short delay to allow user actions
                setTimeout(() => {
                    isSyncingFromHost = false;
                    console.log('[DATA] Reset isSyncingFromHost flag');
                }, 2000);
                return;
            }

            // Remove hidden tab pause suppression - allow all pauses to be sent
            // We want videos to keep playing regardless of tab focus

            // Allow state changes during new video loading
            if (loadingNewVideo) {
                console.log('[DATA] Allowing state change during video loading');
                // Clear the flag once we start playing the new video
                if (data.state === YT.PlayerState.PLAYING) {
                    loadingNewVideo = false;
                }
            } else {
                // Improved ad/buffer suppression - only suppress if we have a valid officialVideoDuration
                // and this isn't a video loading state (UNSTARTED, BUFFERING)
                if (data.state !== YT.PlayerState.PAUSED && 
                    data.state !== YT.PlayerState.ENDED && 
                    data.state !== YT.PlayerState.UNSTARTED && 
                    data.state !== YT.PlayerState.BUFFERING) {
                    
                    if (officialVideoDuration > 0) {
                        const currentDuration = typeof player.getDuration === 'function' ? player.getDuration() : 0;
                        if (currentDuration === 0 || Math.abs(currentDuration - officialVideoDuration) > 2) {
                            console.log("Ad/buffer detected. Suppressing non-pause request to host.");
                            return;
                        }
                    }
                }
            }
        }

        // If this is a user-initiated action, reset the sync flag
        if (data.userInitiated) {
            isSyncingFromHost = false;
            console.log('[DATA] Reset isSyncingFromHost due to user action');
        }

        const requestData = { ...data, type: `REQUEST_${data.type}` };
        const hostChannel = dataChannels['host'];
        if (hostChannel && hostChannel.readyState === 'open') {
            hostChannel.send(JSON.stringify(requestData));
        } else {
            console.warn("Host channel not open; cannot send request.");
        }
    }

    function broadcastData(data) {
        // Remove hidden tab pause suppression - allow all state changes to be broadcasted
        
        handleReceivedData(data, 'local');
        Object.entries(dataChannels).forEach(([id, channel]) => {
            if (id !== 'host' && channel && channel.readyState === 'open') {
                channel.send(JSON.stringify(data));
            }
        });
    }

    function configureDataChannel(peerId, channel, peerName = '') {
        channel.onopen = () => {
            console.log(`[DC:${peerId}] open`);
            hostMigrationInProgress = false; // Changed from window.migrationInProgress
            updateConnectionStatus();
            if (isHost) {
                const users = { [myAuthId]: { name: myName } };
                Object.entries(peerConnections).forEach(([id, pc]) => {
                    if (pc.peerName) users[id] = { name: pc.peerName };
                });
                broadcastData({ type: 'USER_LIST', users });
                channel.send(JSON.stringify({ type: 'HOST_INFO', hostId: myAuthId }));
                if (player && player.getPlayerState && player.getPlayerState() !== YT.PlayerState.UNSTARTED && player.getVideoData().video_id) {
                    const syncData = { type: 'INITIAL_SYNC', videoId: player.getVideoData().video_id, time: player.getCurrentTime(), state: player.getPlayerState(), duration: player.getDuration(), queue: videoQueue };
                    channel.send(JSON.stringify(syncData));
                } else {
                    broadcastData({ type: 'QUEUE_UPDATE', queue: videoQueue });
                }
            }
        };
        channel.onclose = () => {
            console.log(`[DC:${peerId}] close`);
            
            if (peerId === 'host' && !isHost) {
                console.warn('[DC:host] Host data channel closed');
                
                // Only trigger migration if not already in progress and we haven't become host
                if (!hostMigrationInProgress && !isHost) {
                    console.log('[DC:host] Triggering host migration from data channel close');
                    hostMigrationInProgress = true;
                    setTimeout(() => handleHostDisconnection(), 500);
                }
                return;
            }
            
            // Clean up connections
            delete peerConnections[peerId];
            delete dataChannels[peerId];
            
            // Remove from local user list
            delete localUserList[peerId];
            
            // Clean up Firestore if we're the host
            if (isHost && partyDocRef) {
                partyDocRef.collection('guests').doc(peerId).delete().catch(error => 
                    console.error("Error removing guest document:", error)
                );
            }
            
            updateConnectionStatus();
            
            // Update and broadcast user list
            if (isHost) {
                const users = { [myAuthId]: { name: myName } };
                Object.entries(peerConnections).forEach(([id, pc]) => {
                    if (pc.peerName) users[id] = { name: pc.peerName };
                });
                localUserList = users;
                broadcastData({ type: 'USER_LIST', users });
            }
            
            // Update local UI for everyone
            updateUserList(localUserList);
        };
        channel.onmessage = event => {
            try { handleReceivedData(JSON.parse(event.data), peerId); }
            catch (e) { console.error(`[DC:${peerId}] bad message`, e, event.data); }
        };
    }

    function onPlayerStateChange(event) {
        const state = event.data;
        console.log('[YT] onPlayerStateChange:', state, `(${YT_STATE[state] || 'UNKNOWN'})`, {
            queueLen: videoQueue.length,
            hidden: document.hidden,
            currentVideoId,
        });

        // Show "Up Next" immediately when video ends and queue is empty (before any early returns)
        if (state === YT.PlayerState.ENDED && videoQueue.length === 0) {
            if (!upNextActive) {
                console.log('[UpNext] ENDED with empty queue â€” showing overlay');
                showUpNextOverlay();
                setTimeout(() => populateUpNextSuggestions(), 0);
            }
        }

        // Only hide overlay when playback resumes
        if (state === YT.PlayerState.PLAYING) {
            updateVideoTitle();
            hideUpNextOverlay();
        } else if (state === YT.PlayerState.CUED) {
            updateVideoTitle();
        }

        if (isHost && intentToAutoPlay && state === YT.PlayerState.CUED) {
            intentToAutoPlay = false;
            handleUserAction({ type: 'STATE_CHANGE', state: YT.PlayerState.PLAYING, time: 0, userInitiated: true });
            return;
        }

        // Detect in-iframe selection (e.g., end-screen click that navigates inside iframe)
        try {
            const vid = (player && typeof player.getVideoData === 'function') ? player.getVideoData().video_id : null;
            if (vid && currentVideoId && vid !== currentVideoId) {
                console.log('[YT] Detected in-iframe selection of new video:', vid);
                currentVideoId = vid;
                handleUserAction({ type: 'NEW_VIDEO', videoId: vid, autoPlay: true });
                return;
            }
        } catch (_) {}

        // Ignore pure buffering
        if (state === YT.PlayerState.BUFFERING) return;

        // Suppress duplicate states EXCEPT allow ENDED to still propagate once (overlay handled above)
        if (state !== YT.PlayerState.ENDED && state === lastPlayerState) return;

        lastPlayerState = state;

        const userInitiated = (Date.now() - lastUserGestureAt) < 1500;

        // Track manual pauses to distinguish from auto-pauses
        if (state === YT.PlayerState.PAUSED && userInitiated) {
            isManualPause = true;
            console.log('[YT] Manual pause detected');
        } else if (state === YT.PlayerState.PLAYING) {
            isManualPause = false;
            console.log('[YT] Video playing, clearing manual pause flag');
            
            // Host ad/buffer recovery detection
            if (isHost && player) {
                const currentTime = player.getCurrentTime();
                const currentDuration = player.getDuration();
                
                // If host is playing from near the beginning (0-5 seconds) but has guests
                // and the video has a reasonable duration, request guest positions
                if (currentTime < 5 && currentDuration > 30 && Object.keys(dataChannels).length > 0) {
                    console.log('[REVERSE-SYNC] Host may have restarted from ad, requesting guest positions');
                    
                    // Request current positions from all guests
                    const requestData = { type: 'REQUEST_POSITION' };
                    Object.entries(dataChannels).forEach(([id, channel]) => {
                        if (id !== 'host' && channel && channel.readyState === 'open') {
                            channel.send(JSON.stringify(requestData));
                        }
                    });
                }
            }
            
            // Guest ad detection when starting to play
            if (!isHost && player && officialVideoDuration > 0) {
                const currentDuration = player.getDuration();
                if (currentDuration > 0 && Math.abs(currentDuration - officialVideoDuration) > 10) {
                    console.log(`[GUEST-AD] Ad detected on playback start: ${currentDuration}s vs expected ${officialVideoDuration}s`);
                    attemptAdSkip();
                }
            }
        }

        // Remove hidden tab pause suppression - we want videos to keep playing
        // regardless of tab focus state

        if (userInitiated) {
            lastUserActionTimestamp = Date.now();
        }

        if (isHost && state === YT.PlayerState.PLAYING) {
            const duration = player.getDuration();
            if (Math.abs(duration - officialVideoDuration) > 1) {
                officialVideoDuration = duration;
                broadcastData({ type: 'VIDEO_DURATION', duration: duration });
            }
            
            // Enhanced ad detection and skipping
            checkAndSkipAds();
        }

        const actionData = { type: 'STATE_CHANGE', state, time: player.getCurrentTime(), userInitiated };
        handleUserAction(actionData);
    }

    function handleReceivedData(data, senderId) {
        // Buffer messages if player isn't ready yet
        if (!playerReady && (data.type.includes('VIDEO') || data.type === 'TIME_UPDATE' || data.type === 'STATE_CHANGE' || data.type === 'INITIAL_SYNC' || data.type === 'VIDEO_DURATION')) {
            console.log(`[DATA] Buffering ${data.type} - player not ready yet`);
            pendingMessages.push({ data, senderId });
            return;
        }
        
        // Additional safety check for player methods (in case playerReady flag is wrong)
        if (!player && (data.type.includes('VIDEO') || data.type === 'TIME_UPDATE' || data.type === 'STATE_CHANGE' || data.type === 'INITIAL_SYNC')) {
            console.log(`[DATA] Ignoring ${data.type} - player object not ready yet`);
            return;
        }
        
    // FIXED: Host should process guest requests AND apply them locally
    if (isHost && data.type.startsWith('REQUEST_')) {
        // Collect guest time positions for reverse sync
        if (data.type === 'REQUEST_STATE_CHANGE' && data.time !== undefined) {
            guestTimePositions[senderId] = {
                time: data.time,
                timestamp: Date.now()
            };
            console.log(`[SYNC] Collected time position from guest ${senderId}: ${data.time}`);
        }
        
        const commandData = { ...data, type: data.type.replace('REQUEST_', '') };
        // Apply the command to host's own player first
        handleReceivedData(commandData, 'local');
        // Then broadcast to OTHER guests (exclude the sender to prevent echo)
        Object.entries(dataChannels).forEach(([id, channel]) => {
            if (id !== senderId && id !== 'host' && channel && channel.readyState === 'open') {
                channel.send(JSON.stringify(commandData));
            }
        });
        return;
    }        switch (data.type) {
            case 'HOST_INFO':
                currentHostId = data.hostId;
                break;
            case 'INITIAL_SYNC':
                // Additional safety check for player methods
                if (!player || typeof player.loadVideoById !== 'function') {
                    console.log('[SYNC] Player not ready for INITIAL_SYNC, skipping');
                    return;
                }
                isSyncingFromHost = true;
                officialVideoDuration = data.duration;
                if (player.getVideoData()?.video_id !== data.videoId) {
                    player.loadVideoById(data.videoId, data.time);
                } else {
                    player.seekTo(data.time, true);
                }
                currentVideoId = data.videoId;
                hideUpNextOverlay();
                setTimeout(() => {
                    isSyncingFromHost = true;
                    if (data.state === YT.PlayerState.PLAYING) player.playVideo();
                    else if (data.state === YT.PlayerState.PAUSED) player.pauseVideo();
                }, 1000);
                videoQueue = data.queue;
                updateQueueUI();
                break;
            case 'VIDEO_DURATION':
                officialVideoDuration = data.duration;
                // Clear loading flag once we have the new video duration
                if (loadingNewVideo) {
                    console.log('[DATA] New video loaded, clearing loading flag');
                    loadingNewVideo = false;
                }
                break;
            case 'NEW_VIDEO':
                // Additional safety check
                if (!player || typeof player.loadVideoById !== 'function') {
                    console.log('[DATA] Player not ready for NEW_VIDEO, skipping');
                    return;
                }
                
                // Check if this is from our own request (avoid double processing)
                const currentVideoData = player.getVideoData();
                if (currentVideoData && currentVideoData.video_id === data.videoId) {
                    console.log('[DATA] NEW_VIDEO already loaded locally, syncing state only');
                    currentVideoId = data.videoId;
                    
                    // If this is a sync message and we should auto-play, do it
                    if (data.autoPlay && player.getPlayerState() !== YT.PlayerState.PLAYING) {
                        console.log('[DATA] Auto-playing already loaded video');
                        player.playVideo();
                    }
                    return;
                }
                
                // Only load if we don't have the video loaded or it's different
                console.log('[DATA] Loading NEW_VIDEO from remote:', data.videoId);
                isSyncingFromHost = true;
                loadingNewVideo = true;
                officialVideoDuration = 0;
                currentVideoId = data.videoId;
                hideUpNextOverlay();
                updateVideoTitle();
                
                // Set timeout to reset sync flag
                setTimeout(() => {
                    isSyncingFromHost = false;
                    loadingNewVideo = false;
                }, 5000);
                
                if (isHost && data.autoPlay) {
                    intentToAutoPlay = true;
                }
                player.loadVideoById(data.videoId);
                break;
            case 'STATE_CHANGE': {
                // Additional safety check
                if (!player || typeof player.getCurrentTime !== 'function') {
                    console.log('[DATA] Player not ready for STATE_CHANGE, skipping');
                    return;
                }
                
                // If we're loading a new video, be more lenient with sync
                if (loadingNewVideo) {
                    console.log('[DATA] Applying state change during video loading:', data.state);
                    lastPlayerState = data.state;
                    if (data.state === YT.PlayerState.PLAYING) {
                        player.playVideo();
                        loadingNewVideo = false; // Clear flag once playing
                    } else if (data.state === YT.PlayerState.PAUSED) {
                        player.pauseVideo();
                    }
                    return;
                }
                
                // Check current player state to avoid conflicts
                const currentState = player.getPlayerState();
                
                // Don't sync state changes when player is in UNSTARTED (no video loaded)
                if (currentState === YT.PlayerState.UNSTARTED) {
                    console.log('[DATA] Ignoring state change - player has no video loaded');
                    return;
                }
                
                isSyncingFromHost = true;
                lastPlayerState = data.state;
                
                // Track manual pauses from sync messages
                if (data.state === YT.PlayerState.PAUSED && data.userInitiated) {
                    isManualPause = true;
                    console.log('[DATA] Manual pause received from sync');
                } else if (data.state === YT.PlayerState.PLAYING) {
                    isManualPause = false;
                    console.log('[DATA] Playing state received from sync');
                }
                
                // Set a timeout to reset the sync flag
                setTimeout(() => {
                    isSyncingFromHost = false;
                }, 1500);
                
                if (data.state === YT.PlayerState.PLAYING) {
                    const timeDifference = Math.abs(player.getCurrentTime() - data.time);
                    if (timeDifference > 1.5) {
                        console.log(`Resyncing: Time difference of ${timeDifference.toFixed(2)}s is too large.`);
                        player.seekTo(data.time, true);
                    }
                    player.playVideo();
                } else if (data.state === YT.PlayerState.PAUSED || data.state === YT.PlayerState.ENDED) {
                    player.pauseVideo();
                }
                break;
            }
            case 'TIME_UPDATE':
                // Additional safety check
                if (!player || typeof player.getCurrentTime !== 'function') {
                    console.log('[DATA] Player not ready for TIME_UPDATE, skipping');
                    return;
                }
                if (!isHost) {
                    if (Date.now() - lastUserActionTimestamp < 3000) break;
                    
                    // Check if we're syncing to the same video
                    const currentVideoData = player.getVideoData();
                    const currentVideoId = currentVideoData ? currentVideoData.video_id : null;
                    
                    // If we're loading a new video, ignore time updates for different videos
                    if (loadingNewVideo && currentVideoId && currentVideoId !== data.videoId) {
                        console.log('[DATA] Ignoring TIME_UPDATE for different video during loading');
                        return;
                    }
                    
                    const localTime = player.getCurrentTime();
                    const localState = player.getPlayerState();
                    const timeDifference = Math.abs(localTime - data.time);
                    
                    if (data.state === YT.PlayerState.PLAYING && (localState !== YT.PlayerState.PLAYING || timeDifference > 3.5)) {
                        const currentDuration = player.getDuration();
                        if (officialVideoDuration > 0 && Math.abs(currentDuration - officialVideoDuration) > 2) {
                            console.log('[DATA] Duration mismatch, ignoring sync');
                            break;
                        }
                        
                        // Only sync if we're not in UNSTARTED state (no video loaded)
                        if (localState === YT.PlayerState.UNSTARTED) {
                            console.log('[DATA] Cannot sync - no video loaded locally');
                            break;
                        }
                        
                        isSyncingFromHost = true;
                        player.seekTo(data.time, true);
                        player.playVideo();
                    } 
                    else if (data.state === YT.PlayerState.PAUSED && localState !== YT.PlayerState.PAUSED && localState !== YT.PlayerState.UNSTARTED) {
                        console.log("Heartbeat correcting to PAUSED state.");
                        isSyncingFromHost = true;
                        player.pauseVideo();
                    }
                    
                    // Guest ad detection after time sync
                    if (data.duration && data.duration > 0) {
                        // Check if guest has different duration than expected
                        const localDuration = player.getDuration();
                        if (localDuration > 0 && Math.abs(localDuration - data.duration) > 10) {
                            console.log(`[GUEST-AD] Duration mismatch detected: local ${localDuration}s vs host ${data.duration}s`);
                            attemptAdSkip();
                        }
                    }
                }
                break;
            case 'REQUEST_POSITION':
                // Guest responds with current position
                if (!isHost && player && typeof player.getCurrentTime === 'function') {
                    const currentTime = player.getCurrentTime();
                    const currentState = player.getPlayerState();
                    console.log(`[REVERSE-SYNC] Responding with position: ${currentTime}`);
                    
                    const responseData = { 
                        type: 'POSITION_RESPONSE', 
                        time: currentTime, 
                        state: currentState 
                    };
                    
                    const hostChannel = dataChannels['host'];
                    if (hostChannel && hostChannel.readyState === 'open') {
                        hostChannel.send(JSON.stringify(responseData));
                    }
                }
                break;
            case 'POSITION_RESPONSE':
                // Host collects guest positions for reverse sync
                if (isHost) {
                    guestTimePositions[senderId] = {
                        time: data.time,
                        timestamp: Date.now()
                    };
                    console.log(`[REVERSE-SYNC] Received position from guest ${senderId}: ${data.time}`);
                }
                break;
            case 'ADD_TO_QUEUE':
                if (isHost) {
                    videoQueue.push(data.video);
                    // Broadcast queue update to all guests
                    const queueUpdateData = { type: 'QUEUE_UPDATE', queue: videoQueue };
                    Object.entries(dataChannels).forEach(([id, channel]) => {
                        if (id !== 'host' && channel && channel.readyState === 'open') {
                            channel.send(JSON.stringify(queueUpdateData));
                        }
                    });
                    updateQueueUI(); // Update host's own queue UI
                }
                break;
            case 'PLAY_FROM_QUEUE':
                if (isHost && videoQueue[data.index]) {
                    const videoToPlay = videoQueue.splice(data.index, 1)[0];
                    const newVideoData = { type: 'NEW_VIDEO', videoId: videoToPlay.videoId, autoPlay: true };
                    const queueUpdateData = { type: 'QUEUE_UPDATE', queue: videoQueue };
                    
                    // Apply to host first
                    handleReceivedData(newVideoData, 'local');
                    handleReceivedData(queueUpdateData, 'local');
                    
                    // Then broadcast to guests
                    Object.entries(dataChannels).forEach(([id, channel]) => {
                        if (id !== 'host' && channel && channel.readyState === 'open') {
                            channel.send(JSON.stringify(newVideoData));
                            channel.send(JSON.stringify(queueUpdateData));
                        }
                    });
                }
                break;
            case 'REMOVE_FROM_QUEUE':
                if (isHost) {
                    videoQueue.splice(data.index, 1);
                    const queueUpdateData = { type: 'QUEUE_UPDATE', queue: videoQueue };
                    Object.entries(dataChannels).forEach(([id, channel]) => {
                        if (id !== 'host' && channel && channel.readyState === 'open') {
                            channel.send(JSON.stringify(queueUpdateData));
                        }
                    });
                    updateQueueUI(); // Update host's own queue UI
                }
                break;
            case 'USER_LEAVING':
                console.log('[DATA] User leaving:', senderId);
                
                // Clean up connections and user list
                if (peerConnections[senderId]) {
                    peerConnections[senderId].close();
                    delete peerConnections[senderId];
                }
                
                if (dataChannels[senderId]) {
                    dataChannels[senderId].close();
                    delete dataChannels[senderId];
                }
                
                // Remove user from local user list
                delete localUserList[senderId];
                
                // If we're the host, broadcast updated user list to everyone
                if (isHost) {
                    const users = { [myAuthId]: { name: myName } };
                    Object.entries(peerConnections).forEach(([id, pc]) => {
                        if (pc.peerName) users[id] = { name: pc.peerName };
                    });
                    broadcastData({ type: 'USER_LIST', users });
                    
                    // Also clean up Firestore guest document
                    if (partyDocRef) {
                        partyDocRef.collection('guests').doc(senderId).delete().catch(error => 
                            console.error("Error removing guest document:", error)
                        );
                    }
                }
                
                // Update local UI
                updateUserList(localUserList);
                updateConnectionStatus();
                break;
            case 'QUEUE_UPDATE':
                videoQueue = data.queue;
                updateQueueUI();
                break;
            case 'USER_LIST':
                updateUserList(data.users);
                break;
            case 'CHAT_MESSAGE':
                if (senderId !== 'local') displayChatMessage(data);
                break;
        }
    }

    // Copy invite link handler
    copyInviteBtn.addEventListener('click', async () => {
        const link = inviteLinkInput.value;
        if (!link) return;
        
        try {
            // Modern clipboard API (works in HTTPS contexts)
            await navigator.clipboard.writeText(link);
            copyInviteBtn.textContent = 'Copied!';
            setTimeout(() => (copyInviteBtn.textContent = 'Copy'), 1500);
        } catch (err) {
            console.warn('Modern clipboard failed, trying fallback:', err);
            // Fallback for older browsers or non-HTTPS contexts
            try {
                // Focus the input first
                inviteLinkInput.focus();
                // Select all text
                inviteLinkInput.select();
                // For mobile browsers, ensure full selection
                inviteLinkInput.setSelectionRange(0, inviteLinkInput.value.length);
                
                // Copy the selection
                const success = document.execCommand('copy');
                
                copyInviteBtn.textContent = success ? 'Copied!' : 'Copy failed';
                setTimeout(() => (copyInviteBtn.textContent = 'Copy'), 1500);
                
                // Clear selection
                if (window.getSelection) {
                    window.getSelection().removeAllRanges();
                }
                // Blur the input to remove focus
                inviteLinkInput.blur();
                
            } catch (fallbackErr) {
                console.error('Fallback copy also failed:', fallbackErr);
                copyInviteBtn.textContent = 'Copy failed';
                setTimeout(() => (copyInviteBtn.textContent = 'Copy'), 1500);
            }
        }
    });

    function startHostHeartbeat() {
        if (hostHeartbeatInterval) clearInterval(hostHeartbeatInterval);
        hostHeartbeatInterval = setInterval(() => {
            if (isHost && player && typeof player.getCurrentTime === 'function') {
                const currentState = player.getPlayerState();
                const hostTime = player.getCurrentTime();
                
                if (currentState === YT.PlayerState.ENDED && videoQueue.length > 0) {
                    const nextVideo = videoQueue.shift();
                    hideUpNextOverlay();
                    broadcastData({ type: 'NEW_VIDEO', videoId: nextVideo.videoId, autoPlay: true });
                    broadcastData({ type: 'QUEUE_UPDATE', queue: videoQueue });
                    return;
                }
                
                // Check for reverse sync scenario (host behind guests due to ad/buffer)
                if (currentState === YT.PlayerState.PLAYING && Object.keys(guestTimePositions).length > 0) {
                    const now = Date.now();
                    const recentGuestPositions = [];
                    
                    // Collect recent guest positions (within last 5 seconds)
                    Object.entries(guestTimePositions).forEach(([guestId, posData]) => {
                        if (now - posData.timestamp < 5000) {
                            recentGuestPositions.push(posData.time);
                        }
                    });
                    
                    if (recentGuestPositions.length > 0) {
                        const avgGuestTime = recentGuestPositions.reduce((sum, time) => sum + time, 0) / recentGuestPositions.length;
                        const timeDifference = avgGuestTime - hostTime;
                        
                        // If host is significantly behind guests (10+ seconds), sync host to guests
                        if (timeDifference > 10) {
                            console.log(`[REVERSE-SYNC] Host behind by ${timeDifference.toFixed(2)}s, seeking forward to match guests`);
                            player.seekTo(avgGuestTime, true);
                            
                            // Clear guest positions after sync
                            guestTimePositions = {};
                            
                            // Don't send normal time update this cycle
                            return;
                        }
                    }
                }
                
                const data = { type: 'TIME_UPDATE', time: hostTime, state: currentState };
                Object.entries(dataChannels).forEach(([id, channel]) => {
                    if (id !== 'host' && channel && channel.readyState === 'open') {
                        channel.send(JSON.stringify(data));
                    }
                });
            }
        }, 1500);
    }

    async function handleHostDisconnection() {
        if (hostMigrationInProgress) {
            console.log('[MIGRATION] Already in progress, ignoring duplicate call');
            return;
        }
        
        hostMigrationInProgress = true;
        console.log('[MIGRATION] Host disconnected, starting election process...');
        
        // Set a safety timeout to reset migration flag if it gets stuck
        const migrationTimeout = setTimeout(() => {
            console.warn('[MIGRATION] Migration timeout - resetting flag');
            hostMigrationInProgress = false;
        }, 15000);
        
        // Update UI immediately
        connectionStatus.textContent = 'Status: Host disconnected, electing new host...';
        connectionStatus.className = 'status connecting';
        
        try {
            // Step 1: Clean up all existing connections
            await cleanupAllConnections();
            
            // Step 2: Determine if we should become host
            const shouldBecomeHost = await determineNewHost();
            
            if (shouldBecomeHost) {
                console.log('[MIGRATION] This client will become the new host');
                await becomeNewHost();
            } else {
                console.log('[MIGRATION] Waiting for another client to become host');
                await waitForNewHost();
            }
            
            clearTimeout(migrationTimeout);
            
        } catch (error) {
            console.error('[MIGRATION] Host migration failed:', error);
            clearTimeout(migrationTimeout);
            hostMigrationInProgress = false;
            
            // Fallback: refresh the page
            alert('Host migration failed. The page will refresh to reconnect.');
            window.location.reload();
        }
    }

    // Step 1: Clean up all existing connections
    async function cleanupAllConnections() {
        console.log('[MIGRATION] Cleaning up existing connections');
        
        // Close all peer connections
        for (const [peerId, pc] of Object.entries(peerConnections)) {
            try {
                pc.close();
            } catch (e) {
                console.warn('[MIGRATION] Error closing connection:', peerId, e);
            }
            delete peerConnections[peerId];
        }
        
        // Close all data channels
        for (const [peerId, channel] of Object.entries(dataChannels)) {
            try {
                if (channel.readyState === 'open') {
                    channel.close();
                }
            } catch (e) {
                console.warn('[MIGRATION] Error closing channel:', peerId, e);
            }
            delete dataChannels[peerId];
        }
        
        // Clear intervals
        if (hostHeartbeatInterval) {
            clearInterval(hostHeartbeatInterval);
            hostHeartbeatInterval = null;
        }
        
        // Reset connection state
        isHost = false;
        currentHostId = '';
        
        // Clear user list except for ourselves
        localUserList = { [myAuthId]: { name: myName } };
        updateUserList(localUserList);
        
        console.log('[MIGRATION] Cleanup complete');
    }

    // Step 2: Determine who should become the new host
    async function determineNewHost() {
        try {
            // Get all connected users (including ourselves)
            const allUsers = { ...localUserList };
            if (!allUsers[myAuthId]) {
                allUsers[myAuthId] = { name: myName };
            }
            
            // Sort user IDs deterministically (alphabetical order)
            const sortedUserIds = Object.keys(allUsers).sort();
            
            console.log('[MIGRATION] All users for election:', sortedUserIds);
            console.log('[MIGRATION] My ID:', myAuthId);
            
            // The first user in sorted order becomes host
            const newHostId = sortedUserIds[0];
            
            console.log('[MIGRATION] Elected host ID:', newHostId);
            return newHostId === myAuthId;
            
        } catch (error) {
            console.error('[MIGRATION] Error determining new host:', error);
            // Fallback: always try to become host if we can't determine
            return true;
        }
    }

    // Step 3A: Become the new host
    async function becomeNewHost() {
        try {
            console.log('[MIGRATION] Attempting to claim host role...');
            
            // Use a transaction to safely claim host role
            await db.runTransaction(async (transaction) => {
                const partyDoc = await transaction.get(partyDocRef);
                
                if (!partyDoc.exists) {
                    throw new Error('Party document no longer exists');
                }
                
                const currentData = partyDoc.data();
                const currentHostId = currentData.hostId;
                
                // Only proceed if current host is different (avoid race conditions)
                if (currentHostId === myAuthId) {
                    console.log('[MIGRATION] Already the host, skipping');
                    return;
                }
                
                // Claim host role
                transaction.update(partyDocRef, {
                    hostId: myAuthId,
                    migratedAt: firebase.firestore.FieldValue.serverTimestamp(),
                    previousHostId: currentHostId
                });
                
                console.log('[MIGRATION] Host role claimed in Firestore');
            });
            
            // Clean up old guest documents
            await cleanupOldGuestDocuments();
            
            // Update local state
            isHost = true;
            currentHostId = myAuthId;
            
            // Update UI
            updateUIForNewHost();
            
            // Start host functionality
            listenForGuests();
            startHostHeartbeat();
            
            // Broadcast to any remaining connections
            broadcastData({ 
                type: 'HOST_INFO', 
                hostId: myAuthId 
            });
            
            broadcastData({ 
                type: 'USER_LIST', 
                users: localUserList 
            });
            
            console.log('[MIGRATION] Successfully became new host');
            hostMigrationInProgress = false;
            updateConnectionStatus();
            
        } catch (error) {
            console.error('[MIGRATION] Failed to become host:', error);
            throw error;
        }
    }

    // Step 3B: Wait for another client to become host
    async function waitForNewHost() {
        return new Promise((resolve, reject) => {
            console.log('[MIGRATION] Waiting for new host...');
            
            // Set a timeout in case no one becomes host
            const timeout = setTimeout(() => {
                console.warn('[MIGRATION] Timeout waiting for new host');
                unsubscribe();
                reject(new Error('Timeout waiting for new host'));
            }, 10000); // 10 second timeout
            
            // Listen for host changes
            const unsubscribe = partyDocRef.onSnapshot(
                (doc) => {
                    if (!doc.exists) {
                        console.error('[MIGRATION] Party document deleted');
                        clearTimeout(timeout);
                        unsubscribe();
                        reject(new Error('Party document deleted'));
                        return;
                    }
                    
                    const data = doc.data();
                    const newHostId = data.hostId;
                    
                    // Check if we have a new host (and it's not us)
                    if (newHostId && newHostId !== myAuthId && newHostId !== currentHostId) {
                        console.log('[MIGRATION] New host detected:', newHostId);
                        
                        clearTimeout(timeout);
                        unsubscribe();
                        
                        // Update local state
                        currentHostId = newHostId;
                        
                        // Reconnect as guest
                        reconnectAsGuest()
                            .then(() => {
                                hostMigrationInProgress = false;
                                resolve();
                            })
                            .catch(reject);
                    }
                },
                (error) => {
                    console.error('[MIGRATION] Error listening for new host:', error);
                    clearTimeout(timeout);
                    unsubscribe();
                    reject(error);
                }
            );
        });
    }

    // Reconnect to new host as guest
    async function reconnectAsGuest() {
        try {
            console.log('[MIGRATION] Reconnecting as guest to new host');
            
            // Small delay to let new host initialize
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // Join as guest
            await joinParty();
            
            console.log('[MIGRATION] Successfully reconnected as guest');
            updateConnectionStatus();
            
        } catch (error) {
            console.error('[MIGRATION] Failed to reconnect as guest:', error);
            throw error;
        }
    }

    // Helper: Clean up old guest documents
    async function cleanupOldGuestDocuments() {
        try {
            console.log('[MIGRATION] Cleaning up old guest documents');
            
            const guestsSnapshot = await partyDocRef.collection('guests').get();
            
            if (!guestsSnapshot.empty) {
                const batch = db.batch();
                guestsSnapshot.docs.forEach(doc => {
                    batch.delete(doc.ref);
                });
                await batch.commit();
                console.log('[MIGRATION] Cleared old guest documents');
            }
            
        } catch (error) {
            console.warn('[MIGRATION] Error cleaning guest documents:', error);
            // Non-fatal error
        }
    }

    // Update the existing updateUIForNewHost function
    function updateUIForNewHost() {
        // Show create invite button again
        createInviteBtn.classList.remove('hidden');
        createInviteBtn.disabled = false;
        createInviteBtn.textContent = 'Create Invite Link';
        
        // Hide existing invite link
        inviteRow.classList.add('hidden');
        inviteLinkInput.value = '';
        
        // Update user list
        updateUserList(localUserList);
        
        console.log('[MIGRATION] UI updated for new host');
    }

    function updateVideoTitle() {
        if (player && typeof player.getVideoData === 'function') {
            const title = player.getVideoData().title;
            if (title) {
                videoTitleElement.textContent = title;
                videoTitleElement.title = title;
            }
        }
    }

    function updateQueueUI() {
        queueList.innerHTML = '';
        if (videoQueue.length === 0) {
            queueList.innerHTML = '<li>Queue is empty.</li>';
            return;
        }
        videoQueue.forEach((video, index) => {
            const li = document.createElement('li');
            li.title = "Click to Play Now";
            li.innerHTML = `<img src="${video.thumbnailUrl}" alt="${video.title}"><div class="video-info"><div class="video-title">${video.title}</div><button class="remove-btn" title="Remove from queue" data-index="${index}">Remove</button></div>`;
            li.addEventListener('click', (e) => {
                if (e.target.classList.contains('remove-btn')) return;
                handleUserAction({ type: 'PLAY_FROM_QUEUE', index });
            });
            li.querySelector('.remove-btn').addEventListener('click', (e) => {
                e.stopPropagation();
                handleUserAction({ type: 'REMOVE_FROM_QUEUE', index });
            });
            queueList.appendChild(li);
        });
    }

    function updateConnectionStatus() {
        const states = Object.values(peerConnections).map(pc => pc.connectionState);
        let statusText = 'Disconnected';
        let statusClass = 'disconnected';
        const connectedCount = states.filter(s => s === 'connected').length;
        if (isHost && states.length === 0) {
            statusText = 'Waiting for guests...';
            statusClass = 'connecting';
        } else if (connectedCount > 0 || (!isHost && peerConnections['host'] && peerConnections['host'].connectionState === 'connected')) {
            statusText = 'Connected';
            statusClass = 'connected';
        } else if (!isHost && states.some(s => ['connecting', 'new', 'checking'].includes(s))) {
            statusText = 'Connecting...';
            statusClass = 'connecting';
        }
        // Show just "Connected" when connected; otherwise keep the "Status: ..." prefix
        connectionStatus.textContent = statusClass === 'connected' ? 'Connected' : `Status: ${statusText}`;
        connectionStatus.className = `status ${statusClass}`;
    }

    function updateUserList(users = {}) {
        localUserList = users;
        userList.innerHTML = '';
        const uniqueUsers = {};
        Object.values(users).forEach(user => {
            if (user.name && !uniqueUsers[user.name]) {
                uniqueUsers[user.name] = user;
            }
        });
        if (!uniqueUsers[myName]) {
            uniqueUsers[myName] = { name: myName };
        }
        Object.values(uniqueUsers).forEach(user => {
            const li = document.createElement('li');
            let suffix = '';
            if (user.name === myName) {
                suffix = isHost ? ' (Host, You)' : ' (You)';
            }
            li.textContent = user.name + suffix;
            userList.appendChild(li);
        });
    }
</script>

</body>
</html>